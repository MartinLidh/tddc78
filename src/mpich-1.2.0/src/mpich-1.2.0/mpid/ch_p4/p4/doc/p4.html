<TITLE>p4 User's Guide</TITLE>
  
<P>
       
<H1>User's Guide to the p4 Parallel Programming System</H1>
  
<P>

This is both the reference manual and the User's Guide for the p4 parallel  
programming system.  It contains definitions of all functions for both C and  
Fortran, examples, a brief tutorial, and discussions of related systems.  
  
<H3>Ralph Butler</H3>
<P> and  <P>
<H3>Ewing Lusk</H3>
<P>
<HR>
<a href="p4.html#Node47"> Function Index</a>
<P>
 <HR><H0><A NAME="Node0">Contents</a></H0>
<menu> 
<li><a href="p4.html#Node1"> Introduction</a>
<li><a href="p4.html#Node2"> Structure of the Distribution Directory</a>
<li><a href="p4.html#Node3"> Installing p4</a>
<menu> 
<li><a href="p4.html#Node4"> Installing the p4 System</a>
<li><a href="p4.html#Node5"> Installing the Documentation</a>
<li><a href="p4.html#Node6"> Examples included with the Distribution</a>
</menu> 
<li><a href="p4.html#Node7"> Getting Started</a>
<menu> 
<li><a href="p4.html#Node8"> A Message-Passing Example</a>
<li><a href="p4.html#Node9"> Program Description</a>
<li><a href="p4.html#Node10"> Analysis of the Program</a>
</menu> 
<li><a href="p4.html#Node11"> Specifying Processes in the Procgroup File</a>
<li><a href="p4.html#Node12"> Developing a Simple p4 Program</a>
<menu> 
<li><a href="p4.html#Node13"> A Minimal Example</a>
<li><a href="p4.html#Node14"> A Minimal Example in Fortran</a>
<li><a href="p4.html#Node15"> A More Complicated Example</a>
</menu> 
<li><a href="p4.html#Node16"> Command-Line Arguments</a>
<li><a href="p4.html#Node17"> The p4 Function Library</a>
<menu> 
<li><a href="p4.html#Node18"> Overview of the Library</a>
<li><a href="p4.html#Node19"> Return Codes from p4 Functions</a>
</menu> 
<li><a href="p4.html#Node20"> p4 Functions for Managing Processes and Clusters</a>
<menu> 
<li><a href="p4.html#Node21"> Functions for Process Management</a>
<li><a href="p4.html#Node22"> Functions for Cluster Management</a>
</menu> 
<li><a href="p4.html#Node23"> Functions for Message Passing</a>
<menu> 
<li><a href="p4.html#Node24"> Explicit Sending and Receiving of Messages</a>
<li><a href="p4.html#Node25"> Global Operations</a>
</menu> 
<li><a href="p4.html#Node26"> Functions for Shared Memory</a>
<menu> 
<li><a href="p4.html#Node27"> Managing Shared and Local Memory</a>
<li><a href="p4.html#Node28"> Shared Memory Data Types</a>
<li><a href="p4.html#Node29"> Monitor-Building Primitives</a>
<li><a href="p4.html#Node30"> Some Useful Monitors</a>
</menu> 
<li><a href="p4.html#Node31"> Functions for Timing p4 Programs</a>
<li><a href="p4.html#Node32"> Functions for Debugging p4 Programs</a>
<li><a href="p4.html#Node33"> Miscellaneous Functions</a>
<li><a href="p4.html#Node34"> Fortran Interface</a>
<li><a href="p4.html#Node35"> Faster Startup with the Secure Server</a>
<li><a href="p4.html#Node36"> Utilities for Managing a p4 Session</a>
<li><a href="p4.html#Node37"> Creating Logfiles for Upshot</a>
<menu> 
<li><a href="p4.html#Node38"> User-Specified Events</a>
<li><a href="p4.html#Node39"> Creating Log Files in Fortran</a>
<li><a href="p4.html#Node40"> Examining Log Files with Upshot</a>
<li><a href="p4.html#Node41"> Automatic Logging of p4 Events</a>
</menu> 
<li><a href="p4.html#Node42"> Running p4 on Specific Machines</a>
<menu> 
<li><a href="p4.html#Node43"> Invoking a p4 Program</a>
<li><a href="p4.html#Node44"> Machine-Specific Notes</a>
</menu> 
<li><a href="p4.html#Node45"> Some Common Problems and their Solutions</a>
<li><a href="p4.html#Node46"> Concept Index</a>
<li><a href="p4.html#Node47"> Function Index</a>
</menu> 
<P>
<HR><H1><A NAME="Node1">Introduction</a></H1>
<A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node2"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node2"> Structure of the Distribution Directory</a>
<P>
P4 is a library of macros and subroutines developed at Argonne National  
Laboratory for programming a variety of parallel machines.  A paper  
describing its functions and use is [(ref butler-lusk:p4-paper)].  Its  
predecessor was the m4-based ``Argonne macros'' system described in the  
Holt, Rinehart, and Winston book <em> Portable Programs for Parallel  
Processors</em>, by Lusk, Overbeek, et al., from which p4 takes its  
name[(ref lusk-overbeek:p4-book)].  The current p4 system maintains the  
same basic computational models described there (monitors for the  
shared-memory model, message-passing for the distributed-memory model,  
and support for combining the two models) while significantly increasing  
ease and flexibility of use. See section <a href="p4.html#Node7">Getting Started</a> for a simple example.  
<P>
P4 is intended to be portable, simple to install and use, and efficient.  It  
can be used to program networks of workstations, advanced parallel  
supercomputers like the Intel Touchstone Delta and the Alliant Campus  
HiPPI-based system, and single shared-memory multiprocessors.  It has  
currently been installed on the following list of machines: Sequent Symmetry  
(Dynix and PTX), Convex, Encore Multimax, Alliant FX/8, FX/800, and FX/2800,  
Cray X/MP, Sun (SunOS and Solaris), NeXT, DEC, Silicon Graphics, HP, and IBM  
RS6000 workstations, Stardent Titan, BBN GP-1000 and TC-2000, Kendall Square,  
nCube, Intel IPSC/860, Intel Touchstone Delta, Intel Paragon, Alliant Campus,  
Thinking Machines' CM-5, and the IBM SP-1 (TCP/Ethernet, TCP/switch, EUI, and  
EUI-H).  It is not difficult to port to new systems.  Although p4 tries to be  
completely portable, there are a small number of specific exceptions  
(See section <a href="p4.html#Node44">Machine-Specific Notes</a>) that may need to be taken into account on a  
given machine.  
<P>
You can obtain the complete distribution of p4 by anonymous ftp from  
<tt>info.mcs.anl.gov</tt> in the directory <em>pub/p4</em>.  See the <tt>README</tt>  
file there for recent news on what is available.  Take the file  
<em>p4-1.4.tar.Z</em>.  The distribution contains all source code,  
installation instructions, this reference manual, and a collection of examples  
in both C and Fortran. <tt>Alog</tt> is included in the distribution with p4.  
The file <em>upshot.tar.Z</em> contains display facilities that can be used with  
p4 and other systems.  
<P>
To ask questions about p4, report bugs, contribute examples, etc., you can  
send mail to <tt>p4@mcs.anl.gov</tt>.  
<P>
The current release is version 1.4.  You can check which version of the source  
code you have by looking at the file <em>lib/p4_patchlevel.h</em> in the  
distribution.  You can check which version of the object code you have linked  
to by running any p4 program with the command-line option <tt>-p4version</tt>  
(See section <a href="p4.html#Node16">Command-Line Arguments</a>).  
<P>
Salient features of p4 include:   
<ul> 
 
<li>support for both message-passing and explicit shared memory operations  
 
<li><tt>xdr</tt> support for heterogeneous networks  
 
<li>World Wide Web version of the manual for on-line help  
 
<li>SYSV IPC support for shared-memory multiprocessing on workstations that  
  support multiple processors, and simulating it on uniprocessors  
 
<li>instrumentation for automatic logging/tracing  
 
<li>automatic or user control of message-passing/buffer-management  
 
<li>error/interrupt handling  
 
<li>an optional p4 server for quick startup on remote machines  
</ul> 
<BR> 
A useful companion system is the <tt>alog/upshot</tt> logging and X-based trace  
examination facility.  (See section <a href="p4.html#Node37">Creating Logfiles for Upshot</a>.)  
<P>
 <P>
<HR><H1><A NAME="Node2">Structure of the Distribution Directory</a></H1>
<A HREF="p4.html#Node1"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node3"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node3"> Installing p4</a>
<b>Previous: </b><A HREF="p4.html#Node1"> Introduction</a>
<P>
  
<P>
The p4 source code distribution contains the following files and  
subdirectories:  
<P>
  
<dl> 
 
<dt> 
<b>CHANGES</b><dd> 
Changes new to this release of p4.  
 
<dt> 
<b>Makefile</b><dd> 
The makefile for making the p4 system, doing the installation,  
  and making makefiles for user applications.  
 
<dt> 
<b>OPTIONS</b><dd> 
A file controlling various compile-time options, such as  
  whether System V shared-memory operations are to be enabled, whether system  
  debug message printing is to be enabled, and whether automatic  
  instrumentation of internal p4 operations for the <tt>upshot</tt> logging and  
  tracing program is to be done.  It also contains the full pathname of the  
  listener to be used.  
 
<dt> 
<b>README</b><dd> 
General instructions, including how to build and install pr.  
 
<dt> 
<b>alog</b><dd> 
Source code for the ALOG tracing package.  
 
<dt> 
<b>bin</b><dd> 
Scripts for starting and killing servers, killing runaway p4  
  processes, merging <tt>upshot</tt> logfiles, and other useful utilities.  
 
<dt> 
<b>contrib</b><dd> 
Examples contributed by p4 users.  
 
<dt> 
<b>contrib_f</b><dd> 
Fortran examples contributed by users.  
 
<dt> 
<b>doc</b><dd> 
The man page, together with this manual and supporting files,  
  including a reference card for p4 routines.  
 
<dt> 
<b>include</b><dd> 
The include directory for making p4 applications.  Most of  
  these are (hard) links into the <tt>lib</tt> directory.  
 
<dt> 
<b>lib</b><dd> 
The source code for the p4 system.  
 
<dt> 
<b>lib_f</b><dd> 
The Fortran interface for p4.    
 
<dt> 
<b>messages</b><dd> 
A basic set of message-passing examples in C.  
 
<dt> 
<b>messages_f</b><dd> 
A basic set of message-passing examples in Fortran.  
 
<dt> 
<b>misc</b><dd> 
A few odds and ends of programs that fit no special category.  
  Some of these have been found useful during debugging.  
 
<dt> 
<b>monitors</b><dd> 
A basic set of shared-memory examples in C.  
 
<dt> 
<b>servers</b><dd> 
The secure and insecure servers.  
 
<dt> 
<b>usc</b><dd> 
The portable microsecond clock routines.  
 
<dt> 
<b>util</b><dd> 
Assorted supporting files, particularly for making the p4  
  distribution.   
</dl> 
<BR> 
 <P>
<HR><H1><A NAME="Node3">Installing p4</a></H1>
<A HREF="p4.html#Node2"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node4"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node4"> Installing the p4 System</a>
<b>Previous: </b><A HREF="p4.html#Node2"> Structure of the Distribution Directory</a>
<P>
  
<P>
In this section we describe how to install the p4 library, either for  
your own personal use or for the use of everyone at your site.  In the  
first case you do not need any super-user privileges.  In the second  
case, you may or may not, depending on how things are configured at  
your site.  We also describe how to install and run the examples that  
come with p4, the online help system (this manual as a World Wide Web document)  
and how to build a working directory for your own programs yet share  
the installed copy of p4 with other users.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node4">Installing the p4 System</a></H2>
<A HREF="p4.html#Node3"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node3"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node5"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node3"> Installing p4</a>
<b>Next: </b><A HREF="p4.html#Node5"> Installing the Documentation</a>
<b>Previous: </b><A HREF="p4.html#Node3"> Installing p4</a>
<P>
To build p4, position yourself in the top-level p4 directory (Here we refer to  
this directory as <tt>p4</tt>, but you may have it as <tt>p4-1.4</tt> or something  
similar) and type:  
<BR> 
<pre> 
<tt> 
make all P4ARCH=&lt;machine&gt; 
</tt></pre> 
  
where &lt;machine&gt; is one of the machine names listed in  
<em>p4/util/machines</em>, currently:  
  
<P>
<dl> 
 
<dt> 
<b>SUN</b><dd> 
Sun-3, Sun386i, Sparc-1, Sparc-2, or Sparc-10 workstations, running  
  SunOS  
<P>
 
<dt> 
<b>SUN_SOLARIS</b><dd> 
Sun workstations running Solaris  
<P>
 
<dt> 
<b>HP</b><dd> 
HP workstations  
<P>
 
<dt> 
<b>DEC5000</b><dd> 
Dec 5000 workstations  
<P>
 
<dt> 
<b>ALPHA</b><dd> 
Dec Alpha workstations  
<P>
 
<dt> 
<b>NEXT</b><dd> 
68030- or 68040-based NeXT workstations  
<P>
 
<dt> 
<b>RS6000</b><dd> 
IBM RS 6000 series workstations  
<P>
 
<dt> 
<b>LINUX</b><dd> 
IBM-compatible PC's running the LINUX operating system  
<P>
 
<dt> 
<b>IBM3090</b><dd> 
IBM 3090 running IBM's version of UNIX, AIX  
<P>
 
<dt> 
<b>BALANCE</b><dd> 
Sequent Balance shared-memory multiprocessor  
<P>
 
<dt> 
<b>SYMMETRY</b><dd> 
Sequent Symmetry shared-memory multiprocessor  
<P>
 
<dt> 
<b>SYMMETRY_PTX</b><dd> 
Sequent Symmetry shared-memory multiprocessor PTX OS  
<P>
 
<dt> 
<b>MULTIMAX</b><dd> 
Encore Multimax shared-memory multiprocessor  
<P>
 
<dt> 
<b>GP_1000</b><dd> 
BBN GP-1000  
<P>
 
<dt> 
<b>TC_2000</b><dd> 
BBN TC-2000  
<P>
 
<dt> 
<b>TC_2000_TCMP</b><dd> 
BBN TC-2000 with the TCMP message-passing library  
<P>
 
<dt> 
<b>IPSC860</b><dd> 
Intel IPSC/860 (nodes only)  
<P>
 
<dt> 
<b>IPSC860_SOCKETS</b><dd> 
Intel IPSC/860 with socket libraries on the nodes  
<P>
 
<dt> 
<b>DELTA</b><dd> 
Intel DELTA   
<P>
 
<dt> 
<b>PARAGON</b><dd> 
Intel Paragon  
<P>
 
<dt> 
<b>TITAN</b><dd> 
Stardent Titan  
<P>
 
<dt> 
<b>SGI</b><dd> 
Silicon Graphics workstations  
<P>
 
<dt> 
<b>CRAY</b><dd> 
Cray X/MP  
<P>
 
<dt> 
<b>FX8</b><dd> 
Alliant FX/8  
<P>
 
<dt> 
<b>FX2800</b><dd> 
Alliant FX/2800 or FX/800  
<P>
 
<dt> 
<b>FX2800_SWITCH</b><dd> 
Alliant FX/2800 or FX/800, with CAMPUS HiPPI switch  
<P>
 
<dt> 
<b>KSR</b><dd> 
Kendall Square KSR-1  
<P>
 
<dt> 
<b>CM-5</b><dd> 
Thinking Machines' CM-5  
<P>
 
<dt> 
<b>SP1</b><dd> 
IBM SP-1 with TCP interface to either Ethernet or switch  
<P>
 
<dt> 
<b>SP1_EUI</b><dd> 
IBM SP-1 with IBM's EUI interface to the switch  
<P>
 
<dt> 
<b>SP1_EUIH</b><dd> 
IBM SP-1 with IBM's experimental EUI-H switch interface  
<P>
 
<dt> 
<b>MEIKO_CS2</b><dd> 
Meiko Computing Surface  
<P>
</dl> 
<BR> 
                                   
For example:  
<BR> 
<pre> 
<tt> 
make all P4ARCH=SYMMETRY 
</tt></pre> 
  
The <tt>all</tt> is optional, for example  
<BR> 
<pre> 
<tt> 
make P4ARCH=SYMMETRY 
</tt></pre> 
  
This will create a machine-dependent <em>Makefile</em> in each subdirectory,  
make the p4 library, and compile and link a subset of the examples.  
<P>
To add a new machine type, or to change the characteristic parameters  
associated with an existing one, you can edit the file   
<em>p4/util/defs.all</em>.  
<P>
To save disk space, various intermediate object files can be removed with  
<BR> 
<pre> 
<tt> 
make clean 
</tt></pre> 
  
The system can be restored to its original, machine-independent state with  
<BR> 
<pre> 
<tt> 
make realclean 
</tt></pre> 
  
Note that this removes the machine-dependent Makefiles in each directory, so  
the operation is not idempotent.  
<P>
  
It is also possible to install (or clean) only some of the directories:  
<BR> 
<pre> 
<tt> 
make all P4ARCH=SUN DIRS=messages 
make clean DIRS='monitors messages' 
</tt></pre> 
  
To install only the Makefiles in all subdirectories, use:  
<BR> 
<pre> 
<tt> 
make makefiles P4ARCH=&lt;machine&gt; 
</tt></pre> 
  
To install the necessary library and include files in a  
directory everything that is needed to compile and link p4 programs,   
do:  
<P>
<BR> 
<pre> 
<tt> 
make install INSTALLDIR=&lt;dir&gt; 
</tt></pre> 
  
This will create a p4 directory in <tt>&lt;dir&gt;</tt>, build a  
minimal set of directories, copy the relevant <em>.a</em> and <em>.h</em> files  
into it, and test the installation by mking a small set of examples.  
<P>
  
See section <a href="p4.html#Node7">Getting Started</a> for instructions on how to run some example  
programs after you have installed p4.  
<P>
 <P>
<HR><H2><A NAME="Node5">Installing the Documentation</a></H2>
<A HREF="p4.html#Node4"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node3"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node6"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node3"> Installing p4</a>
<b>Next: </b><A HREF="p4.html#Node6"> Examples included with the Distribution</a>
<b>Previous: </b><A HREF="p4.html#Node4"> Installing the p4 System</a>
<P>
  
  
  
<P>
The directory <em>p4/doc</em> contains this manual as well as files that  
require installation.  This manual was prepared with the  
<tt>latexinfo</tt> package from GNU emacs.  
The files in <em>p4/doc</em> are:  
<P>
<dl> 
 
<dt> 
<b>p4.tex</b><dd> 
the latex source for this manual, which uses the latexinfo style  
<P>
 
<dt> 
<b>latexinfo.sty, titlepage.sty</b><dd> 
the style files needed to latex this manual  
<P>
 
<dt> 
<b>p4.html</b><dd> 
an html version of this manual, suitable for being installed  
   in your World Wide Web pages.  
<P>
 
<dt> 
<b>p4.txt</b><dd> 
plain ascii text of the manual, in case nothing else works.  
<P>
 
<dt> 
<b>p4refcard.ps</b><dd> 
postscript version of a reference card  
<P>
 
<dt> 
<b>p4.1</b><dd> 
unix man page for the p4 library  
<P>
 
<dt> 
<b>p4f.1</b><dd> 
unix man page for the Fortran interface to p4  
<P>
 
<dt> 
<b>fiber</b><dd> 
status of the work on direct fiber channel  
<P>
</dl> 
<BR> 
The Postscript version of this manual is available by anonymous <tt>ftp</tt>  
from <tt>info.mcs.anl.gov</tt>, in the directory <em>pub/p4</em>.  The file to get  
(in binary mode) is <em>p4-manual.ps.Z</em>.  There is also a paper there giving  
an overview of p4, in <em>p4-paper.ps.Z</em>.  This manual is also available  
through the World Wide Web at  
<tt>http://www.mcs.anl.gov/home/lusk/p4/p4-manual/p4.html</tt>.  
<P>
 <P>
<HR><H2><A NAME="Node6">Examples included with the Distribution</a></H2>
<A HREF="p4.html#Node5"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node3"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node7"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node3"> Installing p4</a>
<b>Next: </b><A HREF="p4.html#Node7"> Getting Started</a>
<b>Previous: </b><A HREF="p4.html#Node5"> Installing the Documentation</a>
<P>
  
<P>
A good way to see how various p4 functions are used is to look at the example  
programs included in the distribution.  The <em>p4/monitors</em> directory  
contains shared-memory examples written in C that use monitors, including one  
instrumented with ALOG.  The <em>p4/messages</em> subdirectory contains  
message-passing examples written in C.  The programs in <em>p4/messages_f</em>  
are Fortran message-passing examples, and the <em>p4/contrib</em> and  
<em>p4/contrib_f</em> directories contain a number of miscellaneous examples  
contributed by users.  In each directory there is a <em>README</em> that  
describes the individual examples.  
<P>
 <P>
<HR><H1><A NAME="Node7">Getting Started</a></H1>
<A HREF="p4.html#Node6"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node8"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node8"> A Message-Passing Example</a>
<b>Previous: </b><A HREF="p4.html#Node6"> Examples included with the Distribution</a>
<P>
  
<P>
The easiest way to get started with p4 is to play with some of the  
sample programs provided with the system.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node8">A Message-Passing Example</a></H2>
<A HREF="p4.html#Node7"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node7"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node9"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node7"> Getting Started</a>
<b>Next: </b><A HREF="p4.html#Node9"> Program Description</a>
<b>Previous: </b><A HREF="p4.html#Node7"> Getting Started</a>
<P>
We will begin with a message-passing example in the sub-directory named  
<em>p4/messages</em>.  The code for the program is in the files <em>sr_test.c</em>  
and <em>sr_user.h</em>.  
<P>
 <P>
<HR><H2><A NAME="Node9">Program Description</a></H2>
<A HREF="p4.html#Node8"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node7"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node10"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node7"> Getting Started</a>
<b>Next: </b><A HREF="p4.html#Node10"> Analysis of the Program</a>
<b>Previous: </b><A HREF="p4.html#Node8"> A Message-Passing Example</a>
<P>
As the name implies, this program is an example of p4's send/receive  
functionality.  Briefly, it is a simple program that runs a master  
process and some slave processes.  The master and the set of slaves  
form a ring of processes in which the master reads a message from stdin  
and sends a copy of the message to the first slave, which passes it on;  
the last slave passes the message back to the master.  If the master  
receives an undamaged copy of the message, it assumes that all went  
well, and reads another message.  Note that the ring of processes is a  
logical structure in which each process assumes that its  
predecessor in the ring is the process with the next lower id, and  
its successor is the process with the next higher id.  The master  
has id 0 (zero) and has the process with the largest id as its  
predecessor.  
<P>
 <P>
<HR><H2><A NAME="Node10">Analysis of the Program</a></H2>
<A HREF="p4.html#Node9"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node7"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node11"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node7"> Getting Started</a>
<b>Next: </b><A HREF="p4.html#Node11"> Specifying Processes in the Procgroup File</a>
<b>Previous: </b><A HREF="p4.html#Node9"> Program Description</a>
<P>
The first executable p4 statement in a program should be:  
<BR> 
<pre> 
<tt> 
p4_initenv(&amp;argc,argv);  
</tt></pre> 
  
This initializes the p4 system and allows p4 to extract any command  
line arguments passed to it, e.g. debugging parameters.    
<P>
Similarly, the last executable p4 statement in a program should be:  
<BR> 
<pre> 
<tt> 
p4_wait_for_end();  
</tt></pre> 
  
This waits for termination of p4 processes and performs some cleanup  
operations.  
<P>
The procedure <tt>p4_get_my_id</tt> returns the unique integer id assigned  
to the calling process by p4.  
<P>
The statement:  
<BR> 
<pre> 
<tt> 
p4_create_procgroup(); 
</tt></pre> 
  
reads a procgroup file that the user builds and creates the set of  
slaves described in that file.  Obviously this statement must be  
executed before any slaves can be assumed to exist.  This procedure  
is the method you must use to create processes that do message-passing.  
<P>
The procedure <tt>p4_clock</tt> returns an integer that represents  
wall-clock time in milliseconds.  It is typically used to retrieve the  
time before and after some work, the difference representing the time to  
do that work.  Note that there is also a <tt>p4_ustimer</tt> that is useful on  
those machines that support a microsecond timer.  
<P>
The procedures <tt>p4_send</tt> and <tt>p4_sendr</tt> are two of several   
p4 procedures that are available for sending messages to other processes.  
They take as arguments the message type, the id of the "to" process,  
the address of the message, and the message length.  
<P>
The procedure <tt>p4_recv</tt> receives a message from another process and  
sets the values of all four parameters.  <tt>P4_recv</tt> will automatically  
retrieve a buffer in which to place a received message, thus  
<tt>p4_msg_free</tt> may be called to free that buffer when it is no longer  
needed.  
<P>
The procedure <tt>p4_num_total_slaves</tt> is one of several procedures that  
the user can invoke to determine information about the current execution.  
<P>
To run this program, you need to create a procgroup file that describes  
where all slave processes are to be executed   
(See section <a href="p4.html#Node11">Specifying Processes in the Procgroup File</a>).  We will assume that  
you have an example procgroup file (named <em>sr_test.pg</em>) in the   
<em>p4/messages</em> directory, and can run <tt>sr_test</tt> by merely typing:  
<BR> 
<pre> 
<tt> 
sr_test 
</tt></pre> 
  
If the procgroup file is elsewhere, then you must type:  
<BR> 
<pre> 
<tt> 
sr_test -pg  </tt><em> pathname_of_procgroup_file</em> 
</tt></pre> 
  
Another example that is made by default is the program <tt>systest</tt>.  It  
tests a number of the message-passing features of p4.  
<P>
 <P>
<HR><H1><A NAME="Node11">Specifying Processes in the Procgroup File</a></H1>
<A HREF="p4.html#Node10"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node12"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node12"> Developing a Simple p4 Program</a>
<b>Previous: </b><A HREF="p4.html#Node10"> Analysis of the Program</a>
<P>
  
<P>
The procgroup file is the only portion of the interface that is very likely to  
change through multiple versions of p4.  As new architectures are supported,  
it is hoped that we can merely alter the procgroup file format to reflect any  
new features.  (Of course new procedure calls may also be required, but  
existing procedure calls will remain unchanged when possible).  See  
See section <a href="p4.html#Node42">Running p4 on Specific Machines</a> for a discussion of machine  
dependencies in starting p4 programs.  
<P>
The current format of a procgroup file is as follows:  
<BR> 
<pre> 
<tt> 
local_machine  n [full_path_name] [loginname] 
remote_machine n full_path_name [loginname] 
  . 
  . 
  . 
</tt></pre> 
  
<P>
In some situations, the program is started via some  
special command executed from the host machine.  In such cases, the  
procgroup file name can be specified to the special command line along  
with the program name (see for example the <tt>runcube</tt> and <tt>rundelta</tt>  
shell scripts in the <em>p4/messages</em> subdirectory).  In those cases   
where no special command is required, no special handling is required   
for the procgroup filename.  
<P>
The first line of a procgroup file may be ``local n'' where n is the number  
of slave processes that share memory with the master.  The full path  
name on the ``local'' line is ignored on machines other than cube and mesh  
machines, and the IBM SP-1.  The word ``local'' may be replaced by an alias  
for the local machine if needed, to specify an alternative transport layer.  
The subsequent lines contain either three or four  
fields:  
<ol> 
 
<BR> 
1. the name of a remote machine on which slave processes are to be created.  
 
<BR> 
2. the number of slaves that are to be created on that machine,   
i.e. be in the same cluster (note that on machines that support it,   
the processes in a cluster will share memory)  
 
<BR> 
3. the full path name of the executable slave program  
 
<BR> 
4. optionally, the user login name on the remote machine, if different from   
that on the host machine.  
</ol> 
<BR> 
As an example, let's assume that you have a network of three Sun   
workstations named sun1, sun2, and sun3.  We will also assume that you   
are working on sun1 and plan to run a master process there.    
If you would like to run one process on each of the other Suns, then you   
might code a procgroup file that looks like:  
<P>
<BR> 
<pre> 
<tt> 
    # start one slave on each of sun2 and sun3 
    local 0  
    sun2  1  /home/mylogin/p4pgms/sr_test 
    sun3  1  /home/mylogin/p4pgms/sr_test 
</tt></pre> 
Lines beginning with <tt>#</tt> are comments.  
<P>
It is also possible to have different executables on different machines.  This  
is required, of course, when the machines don't share files or are of  
different architectures.  An example of such a procgroup file would be:  
<P>
<BR> 
<pre> 
<tt> 
    local   0 
    sun2    1  /home/user/p4pgms/sun/prog1 
    sun3    1  /home/user/p4pgms/sun/prog2 
    rs6000  1  /home/user/p4pgms/rs6000/prog1 
</tt></pre> 
On a shared memory machine such as a KSR, in which you want all the processes  
to communicate through shared memory using monitors, the procgroup file can be  
as simple as:  
<P>
<BR> 
<pre> 
<tt> 
    local 50 
</tt></pre> 
On the CM-5, your procgroup file would look like:  
<P>
<BR> 
<pre> 
<tt> 
    local 32 /home/joe/p4progs/cm5/multiply 
</tt></pre> 
Next, let's assume that you have a Sequent Symmetry (named <tt>symm</tt>) and an  
Encore Multimax (named <tt>mmax</tt>).  We will also assume that you are working  
on <tt>symm</tt>, and plan to run the master there.  If you would like to run  
two processes on <tt>symm</tt> (in addition to the master) and two on  
<tt>mmax</tt>, then you might code a procgroup file that looks like:  
<P>
<BR> 
<pre> 
<tt> 
    local 2  
    mmax  2  /mmaxfs/mylogin/p4pgms/sr_test 
</tt></pre> 
P4 also permits you to treat the symmetry as a remote machine even when   
you are running the master there.  Thus, you might code a procgroup file   
as follows:  
<P>
<BR> 
<pre> 
<tt> 
    local 2  
    symm  2  /symmfs/mylogin/p4pgms/sr_test 
    mmax  2  /mmaxfs/mylogin/p4pgms/sr_test 
</tt></pre> 
In this example, there are seven processes running.  Five of the  
processes are on symm, including the master.  Two of the processes on  
symm are in the master's procgroup and two are running in a separate  
procgroup as if they were on a separate machine.  Of course, the last  
two are running on mmax.  
<P>
Finally, suppose that you have a fiber-channel network that parallels your  
Ethernet, connecting the same machines, and that connections fro running  
TCP/IP over the fiber-channel network are obtained by connecting to  
<tt>sun1-fc</tt>, <tt>sun2-fc</tt>, etc.  Then even if <tt>sun1</tt> is the local  
machine that you are logged into, you will want your procgroup file to look  
like:  
<P>
<BR> 
<pre> 
<tt> 
    sun1-fc    0 
    sun2-fc    1  /home/user/p4pgms/sun/prog1 
    sun3-fc    1  /home/user/p4pgms/sun/prog2 
</tt></pre> 
Some notes about the contents of the procgroup file should be made at  
this point.  First, the value of <tt>n</tt> on the local line can be zero,  
i.e. the master may have no local slaves.  Second, the local machine  
may be treated as if it is a remote machine by merely entering it in  
some line as a remote machine.  Third, a single machine may be treated  
as multiple remote machines by having the same remote machine name  
entered on multiple lines in the procgroup file.  Fourth, if a single  
machine is listed multiple times, those processes specified on each  
line form a single cluster (share memory).  Fifth, the cluster size  
specified for a uniprocessor should be 1, because all slaves in a  
cluster are assumed to run in parallel and to share memory.  
<P>
We refer to the original (master) process as the ``big master''.  The  
first process created in each cluster is the ``remote master'' or the  
``cluster master'' for that cluster.    
All p4-managed processes (see the procedure <tt>p4_create_procgroup</tt>)   
have unique integer id's beginning with 0.  
The processes within a cluster are numbered consecutively.  
<P>
 <P>
<HR><H1><A NAME="Node12">Developing a Simple p4 Program</a></H1>
<A HREF="p4.html#Node11"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node13"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node13"> A Minimal Example</a>
<b>Previous: </b><A HREF="p4.html#Node11"> Specifying Processes in the Procgroup File</a>
<P>
The real fun associated with any computing environment arrives when you  
actually type in a program and run it yourself.  We will assume that  
you have successfully installed p4 on your own system and are ready to  
write a small program, compile it, and run it.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node13">A Minimal Example</a></H2>
<A HREF="p4.html#Node12"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node12"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node14"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node12"> Developing a Simple p4 Program</a>
<b>Next: </b><A HREF="p4.html#Node14"> A Minimal Example in Fortran</a>
<b>Previous: </b><A HREF="p4.html#Node12"> Developing a Simple p4 Program</a>
<P>
We will start with a tiny program in which the worker processes do no work, and  
then expand its capabilities.  Edit a file called <em>p4simple.c</em> and type:  
<P>
<BR> 
<pre> 
<tt> 
<P>
#include "p4.h" 
<P>
main(argc,argv) 
    int argc; 
    char **argv; 
    { 
        p4_initenv(&amp;argc,argv); 
        p4_create_procgroup(); 
        worker(); 
        p4_wait_for_end(); 
    } 
<P>
worker() 
    { 
        printf("Hello from %d\n",p4_get_my_id()); 
    } 
<P>
</tt></pre> 
This is one of the simplest p4 programs that you can write.  Let's examine it.  
The <tt>#include "p4.h"</tt> statement must appear in all programs that use any  
p4 features.  The procedure <tt>p4_initenv</tt> must be invoked before any other  
p4 procedures, and <tt>p4_wait_for_end</tt> must be invoked after all p4  
processing is completed.  The <tt>p4_get_my_id</tt> returns a unique integer id  
for each process, beginning with 0.  The procedure <tt>p4_create_procgroup</tt>  
is responsible for creating all processes other than 0.  It has no effect if  
called by any other processes than process 0.  The way in which  
<tt>p4_create_procgroup</tt> determines how many other processes there should  
be, and where they should run, will be discussed shortly.  
<P>
All processes that this program executes invoke the worker procedure,  
including process 0.  Thus, in this program, the master process acts  
just like all other processes once it gets the environment  
established.  
<P>
To understand how things get started, let's consider two separate  
situations.  In the first situation, all processes are running on a  
single machine.  Then, when process 0 starts, it executes the  
<tt>p4_create_procgroup</tt> procedure to start all other slaves.  The other  
slaves are started on the same machine by means of a UNIX <tt>fork</tt>.  
<P>
In the second situation, there may be slaves running both on the same  
machine as process 0, and slaves running on other machines as well.  
In this situation, the first slave running on a remote machine will  
need to execute the main procedure.  It will discover that it is not  
process 0.  However, as part of initialization, process 0 will  
direct it to fork any additional slaves required on the same machine.  
<P>
In some ways, the above example can be used as a prototype for all p4 programs,  
just by varying the content of the <tt>worker</tt> routine.  
<P>
 <P>
<HR><H2><A NAME="Node14">A Minimal Example in Fortran</a></H2>
<A HREF="p4.html#Node13"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node12"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node15"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node12"> Developing a Simple p4 Program</a>
<b>Next: </b><A HREF="p4.html#Node15"> A More Complicated Example</a>
<b>Previous: </b><A HREF="p4.html#Node13"> A Minimal Example</a>
<P>
Here is a Fortrran version of the program we just discussed.  
<BR> 
<pre> 
<tt> 
      program p4simple 
      include 'p4f.h' 
<P>
call p4init() 
      call p4crpg() 
      call fworker() 
      call p4cleanup() 
      stop 
      end 
<P>
subroutine fworker() 
      include 'p4f.h' 
      integer*4 procid 
<P>
procid = p4myid() 
      print *,'Hello from ',procid 
<P>
end 
</tt></pre> 
 <P>
<HR><H2><A NAME="Node15">A More Complicated Example</a></H2>
<A HREF="p4.html#Node14"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node12"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node16"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node12"> Developing a Simple p4 Program</a>
<b>Next: </b><A HREF="p4.html#Node16"> Command-Line Arguments</a>
<b>Previous: </b><A HREF="p4.html#Node14"> A Minimal Example in Fortran</a>
<P>
Now, let's make the worker process a little bit more interesting.  Let's  
assume that we have <tt>nprocs</tt> slaves with ids   
0, 1, 2, ... <tt>nprocs</tt> -1.  And, we want to write a program in which  
every process sends a single message to every other slave, and then  
receives a message from every other slave.  We might alter the code for  
the worker procedure to be the following:  
<P>
<BR> 
<pre> 
<tt> 
    worker() 
    { 
        char *incoming, *msg = "hello"; 
        int myid, size, nprocs, from, i, type; 
<P>
myid = p4_get_my_id(); 
        nprocs = p4_num_total_ids(); 
        for (i=0; i &lt; nprocs; i++) 
        { 
            if (i != myid) 
                p4_send(100, i, msg, strlen(msg)+1); 
        } 
        for (i=0; i &lt; nprocs - 1; i++) 
        { 
            type = -1; 
            from = -1; 
            incoming = NULL; 
            p4_recv(&amp;type,&amp;from,&amp;incoming,&amp;size); 
            printf("%d received msg=:%s: from %d",myid,incoming,from); 
            p4_msg_free(incoming); 
        } 
    } 
</tt></pre> 
This program demonstrates several features of p4's support for  
message-passing.  Before we get into the specifics however, let's  
examine the overall logic of the program.  Each process determines its  
own id and the total number of processes executing in this run  
(including process 0).  Then, in the first for-loop, each process sends  
a single message to each of the other processes.  Finally, in the  
second for-loop, each process receives a message from each of the other  
processes.  
<P>
The <tt>p4_send</tt> call requires 4 arguments:  
<ul> 
 
<li>a message type (arbitrarily chosen to be 100 here)  
 
<li>the id of the process to receive the message  
 
<li>the message itself  
 
<li>the size of the message  
</ul> 
<BR> 
The use of <tt>p4_recv</tt> is slightly more complicated.  First, we assign -1  
to each of the parameters <tt>type</tt> and <tt>from</tt>.  This is done because  
-1 represents a wildcard value indicating we are willing to receive a message  
of any type from any process.  Here, we could have coded type to be 100, and  
specified from equal to the value of <tt>i</tt> each time through the loop  
(skipping our own id).  By setting <tt>incoming</tt> to NULL, we have also  
indicated to <tt>p4_recv</tt> that we do not have a buffer in which to place the  
received message, so <tt>p4_recv</tt> should obtain a buffer for us and place  
the message in that buffer.  <tt>p4_recv</tt> treats these three parameters as  
both input and output values.  Thus, it alters the value of each such that  
<tt>type</tt> and <tt>from</tt> indicate the type of message received and the id  
of the process that sent it.  The value of <tt>incoming</tt> is altered to point  
to the buffer where the message was placed.  The <tt>size</tt> parameter is  
strictly an output parameter and indicates the size of the received message.  
It is possible for the user to provide his own buffer; this will be  
demonstrated later.  
<P>
  
Finally, note that <tt>p4_msg_free</tt> frees the message buffer obtained by  
<tt>p4_recv.</tt> The procedure <tt>p4_msg_free</tt> should be called only after  
the contents of the message are no longer needed.  <tt>P4_msg_free</tt> should  
be used to free these buffers because, although a user only sees the data  
portion of a message, p4 internally represents a message as a structured data  
item.  
<P>
To compile and link this program for execution, you need to create a  
makefile.  We will assume that you have installed p4 in  
<em>/usr/local/p4</em> and that you have typed the program above into a  
file name <em>p4simple.c</em> in the directory  
<em>/home/mylogin/p4pgms</em>.  
<P>
To build your makefile, copy the file  
<BR> 
<pre> 
<tt> 
    /usr/local/p4/messages/makefile.proto 
</tt></pre> 
  
into your working directory.  This is a prototype makefile that  
contains machine-independent information, and which p4 can use to build a  
machine-specific makefile for your program.  This prototype makefile contains  
information about several sample programs that demonstrate  
message-passing in p4.  If you edit this file, you will see information  
for making a program named <tt>sr_test</tt>.  Do a global change of  
<tt>sr_test</tt> to <tt>p4simple</tt>.  You should also change the value of  
<tt>P4_HOME_DIR</tt>.  It should contain the full  
pathname of the p4 system, e.g. <em>/usr/local/p4</em>.  Now change  
directories to <em>/usr/local/p4</em> and type:  
<P>
<BR> 
<pre> 
<tt> 
make makefiles P4ARCH=&lt;machine_type&gt; DIRS=/home/mylogin/p4pgms 
</tt></pre> 
  
where <tt>&lt;machine_type&gt;</tt> is the machine type that you specified when  
you installed p4 on your machine.  Now, you should be able to change  
back to your directory and see a file named <em>Makefile</em> there.    
You should then be able to type:  
<P>
<BR> 
<pre> 
<tt> 
    make p4simple 
</tt></pre> 
There is one last piece missing before you can execute your program.  Recall  
that <tt>p4_create_procgroup</tt> needs to know how many processes to start and  
where to start them; it reads a file (called a <em>procgroup file</em>) to gather  
this information.  P4 always assumes that you have a master process, and that  
you describe the slave processes (process groups) in the procgroup file.  You  
can name a procgroup file any name you choose, but <tt>&lt;progname&gt;.pg</tt> is the  
default name.  For example, in this case your procgroup file should be named  
<em>p4simple.pg</em>.  The information contained in procgroup files can get  
fairly involved, but if you have a computer that supports shared memory among  
processes, then you can code a very simple example at first.  
<P>
Let us suppose first that you want to run your program on a network of  
workstations.  Then your procgroup should look something like:  
<P>
<BR> 
<pre> 
<tt> 
    local O 
    some.network.machine 1 /home/me/p4progs/p4simple 
</tt></pre> 
This file indicates that you wish to run only the master on the local machine  
(the one you are logged into when you execute the program) and one slave on  
the machine <tt>some.network.machine</tt>.  
<P>
Now, all you have to do to run your program is type:  
<P>
<BR> 
<pre> 
<tt> 
    p4simple 
</tt></pre> 
You should see a line printed each time a process receives a message  
from another process (on some machines, there may be a restriction that  
only one process can do I/O, however such restrictions are not  
common).  Experiment by changing the number of slaves indicated in the  
procgroup file.  
<P>
You may notice that even a small p4 program becomes large when linked  
with the p4 library.  You might consider using <tt>strip</tt> to reduce  
the size or removing <tt>-g</tt> from the CFLAGS in the makefile.  
<P>
 <P>
<HR><H1><A NAME="Node16">Command-Line Arguments</a></H1>
<A HREF="p4.html#Node15"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node17"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node17"> The p4 Function Library</a>
<b>Previous: </b><A HREF="p4.html#Node15"> A More Complicated Example</a>
<P>
  
<P>
The command-line arguments to a p4 program are all optional.  
<BR> 
<pre> 
<tt> 
  -p4help            get this information, then exit 
  -p4pg      &lt;file&gt;  set procgroup file 
  -p4dbg    &lt;level&gt;  set debug level 
  -p4rdbg   &lt;level&gt;  set remote debug level 
  -p4gm      &lt;size&gt;  set global memory size 
  -p4dmn   &lt;domain&gt;  provide local domain name 
  -p4out     &lt;file&gt;  set output file for master 
  -p4rout    &lt;file&gt;  set output file prefix for remote masters 
  -p4ssport &lt;port#&gt;  set private port number for secure server 
  -p4norem           don't start remote processes 
  -p4log             enable internal p4 logging by alog 
  -p4version         print current p4 version number 
</tt></pre> 
In version 1.4, these flag names are valid without their <tt>p4</tt> prefix, for  
backward compatibility.  
<P>
  
If one specifies <tt>-p4norem</tt> on the command line, p4 will not actually  
start the processes.  The master process prints a message suggesting how the  
user can do it.  The point of this option is to enable the user to start the  
remote processes under his favorite debugger, for instance.  The option only  
makes sense when processes are being started remotely, such as on a  
workstation network.  
<P>
 <P>
<HR><H1><A NAME="Node17">The p4 Function Library</a></H1>
<A HREF="p4.html#Node16"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node18"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node18"> Overview of the Library</a>
<b>Previous: </b><A HREF="p4.html#Node16"> Command-Line Arguments</a>
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node18">Overview of the Library</a></H2>
<A HREF="p4.html#Node17"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node17"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node19"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node17"> The p4 Function Library</a>
<b>Next: </b><A HREF="p4.html#Node19"> Return Codes from p4 Functions</a>
<b>Previous: </b><A HREF="p4.html#Node17"> The p4 Function Library</a>
<P>
In the following sections, we provide details for each p4 function in the  
library.  The procedures are gathered into the following groups:  
<P>
<ul> 
 
<li>Functions for managing processes and clusters  
 
<li>Functions for message passing  
 
<li>Functions for shared memory  
 
<li>Functions for timing p4 programs  
 
<li>Functions for debugging p4 programs  
 
<li>Miscellaneous functions  
 
<li>Fortran interface functions  
</ul> 
<BR> 
 <P>
<HR><H2><A NAME="Node19">Return Codes from p4 Functions</a></H2>
<A HREF="p4.html#Node18"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node17"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node20"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node17"> The p4 Function Library</a>
<b>Next: </b><A HREF="p4.html#Node20"> p4 Functions for Managing Processes and Clusters</a>
<b>Previous: </b><A HREF="p4.html#Node18"> Overview of the Library</a>
<P>
  
<P>
Most p4 functions return -1 if an error occurs.  Some, however, call the  
function <tt>p4_error</tt> when severe errors occur.  This function prints a  
message and then attempts to terminate all of the user's processes  
See section <a href="p4.html#Node32">Functions for Debugging p4 Programs</a>.  
<P>
 <P>
<HR><H1><A NAME="Node20">p4 Functions for Managing Processes and Clusters</a></H1>
<A HREF="p4.html#Node19"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node21"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node21"> Functions for Process Management</a>
<b>Previous: </b><A HREF="p4.html#Node19"> Return Codes from p4 Functions</a>
<P>
In some situations a p4 procedure will give an error message and then  
exit.  This is typically done as a result of a failed system call and  
handled by calling the p4 procedure named <tt>p4_error</tt> that examines the  
return values from socket procedures, etc.  Most of the time however,  
the procedures simply return a value.  Some of the procedures return no  
value and thus are declared to return <tt>VOID</tt>.  Some of the  
procedures return either a pointer to a character string or <tt>NULL</tt>;  
<tt>NULL</tt> indicates an error.  The remaining procedures return an  
integer value; (-1) indicates an error.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node21">Functions for Process Management</a></H2>
<A HREF="p4.html#Node20"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node20"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node22"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node20"> p4 Functions for Managing Processes and Clusters</a>
<b>Next: </b><A HREF="p4.html#Node22"> Functions for Cluster Management</a>
<b>Previous: </b><A HREF="p4.html#Node20"> p4 Functions for Managing Processes and Clusters</a>
<P>
  
<P>
In this section we describe the p4 functions needed for basic creation and  
termination of processes.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_initenv(argc,argv) 
int *argc; 
char **argv; 
</tt></pre> 
   
should be called by your program before an attempt is made to use  
any p4 procedures or data areas.  We suggest making it the first executable  
statement in your program.  <tt>p4_initenv</tt> parses the command line  
arguments and extracts the ones intended for p4 ignoring all others (see the  
discussion of command line arguments).  Note that you pass the address of  
<tt>argc</tt> to <tt>p4_initenv</tt> so that it can actually remove its own  
arguments before your program looks at them.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_create(fxn) 
int (*fxn)(); 
<P>
 
int p4_create_procgroup() 
</tt></pre> 
  
There are two procedures that you can use to create processes in p4,  
<tt>p4_create_procgroup</tt> and <tt>p4_create</tt>.  Processes created via  
<tt>p4_create</tt> are said to be ``user-managed'' whereas those created  
by <tt>p4_create_procgroup</tt> are ``p4-managed''.  The p4-managed  
processes are automatically assigned unique id's (beginning with 0 for  
the big master), they have message queues allocated for them so that  
they can do message-passing, and they are able to run either on a  
shared-memory multiprocessor with the creating process or they can run  
on a separate machine.  Processes created via <tt>p4_create</tt> do not  
have any of these advantages.  They must develop their own id's, they  
cannot do message-passing, and they can only run on a shared-memory  
multiprocessor with the creating process.  The only disadvantage of  
<tt>p4_create_procgroup</tt> is that you must build a <em>procgroup</em>  
file describing the set of required slave processes before the master  
program begins execution.  This eliminates the possibility of  
determining late in the execution exactly how many processes you want  
to use to solve a problem.  Generally, this is not a problem,  
especially since we can combine <tt>p4_create_procgroup</tt> and  
<tt>p4_create</tt> in the following way: You can use  
<tt>p4_create_procgroup</tt> to develop a network of processes that talk  
to each other via messages.  Each of those processes can create further  
processes to help it out as necessary.  The original set of processes  
communicate with their local slaves through shared data areas and with  
each other via message-passing.  
<P>
<tt>p4_create</tt> receives one argument that is a pointer to a function.  It  
creates a single new process that executes the indicated function.  The  
new process may share data areas (in shared memory) with the parent  
process.  However, the new process is not managed by the p4 system in  
the sense that it is not assigned an id, it cannot pass messages, etc.  
The only p4 procedure that deals with user-managed slaves is <tt>p4_create</tt>.  
No other procedures are even aware of their existence.  
<P>
<tt>p4_create_procgroup</tt> reads your procgroup file to determine the number  
of slave processes to create and where they are to be placed.  It looks first  
for the file specified on the command line following the <tt>-p4pg</tt> argument  
if there is one.  If there is no such argument, it looks for a file with the  
same name as the executable (master) file, with the <em>.pg</em> suffix.  If it  
does not find one, it looks for a file named <em>procgroup</em>.  It builds a  
procgroup table that describes all created processes and gives a copy of the  
table to each process.  The processes then use the table to discover how to  
communicate with each other (processes in a cluster can send messages directly  
through shared memory or some other vendor-specific mechanism), others  
communicate via sockets).  An alternative method is to build the table in  
memory yourself and use <tt>p4_startup</tt>.  
<P>
The effect of <tt>p4_create_procgroup</tt> can be obtained in another way if a  
system would prefer to use its own way of specifying the locations of  
processes.  A user may allocate the procgroup data structure and then fill it  
in ``by hand'' rather than by reading a file in p4 procgroup format.  The  
following procedures support this method of starting processes.  
<P>
  
<BR> 
<pre> 
<tt> 
struct p4_procgroup *p4_alloc_procgroup() 
</tt></pre> 
  
allocates a procgroup data structure of the form described in <tt>p4.h</tt>.  
The formats of individual entries (<tt>p4_procgroup_entry</tt>) are given there  
as well.   
<P>
  
<BR> 
<pre> 
<tt> 
int p4_startup(pg) 
struct p4_procgroup *pg; 
</tt></pre> 
  
starts processes as specified by an an already-created procgroup data  
structure allocated by <tt>p4_alloc_procgroup</tt> and filled in by the user  
using the structures <tt>p4_procgroup_entry</tt> and <tt>p4_procgroup</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_wait_for_end() 
</tt></pre> 
  
is the p4 termination/cleanup procedure that you should invoke at  
the end of every execution of a program that uses p4.  For the master process,  
it does some termination processing and then waits for slave processes to end.  
It should be called by all processes.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_get_my_id() 
</tt></pre> 
  
returns an integer value representing the id of the process assigned by  
the p4 system.  If the process is not a p4-managed process, the value  
(-1) is returned.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_num_total_ids() 
</tt></pre> 
  
returns an integer value indicating the total number of ids started  
by p4 in all clusters, including the big master and all remote masters.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_num_total_slaves() 
</tt></pre> 
  
returns an integer value indicating the total number of processes started  
by p4 in all clusters, including all remote masters but not the big master.  
<P>
 <P>
<HR><H2><A NAME="Node22">Functions for Cluster Management</a></H2>
<A HREF="p4.html#Node21"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node20"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node23"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node20"> p4 Functions for Managing Processes and Clusters</a>
<b>Next: </b><A HREF="p4.html#Node23"> Functions for Message Passing</a>
<b>Previous: </b><A HREF="p4.html#Node21"> Functions for Process Management</a>
<P>
  
<P>
The p4 system supports the <em>cluster</em> model of parallel computation, in  
which subsets of processes share memory with one another, with the clusters  
communicating via messages.  A procgroup file for a program written for the  
cluster model might look like this:  
<P>
<BR> 
<pre> 
<tt> 
    local                4 
    alliant1.abc.edu     5 /home/me/myprog 
    alliant2.abc.edu     5 /home/me/myprog 
    encore.somewhere.edu 5 /usrs/me/myprog 
</tt></pre> 
This would specify a total of 20 processes, 5 (including the master) running  
on the local machine (here assumed to be capable of supporting five processes  
that share memory) together with 5 slaves each on three other shared-memory  
machines.  One process out of each set of remote slaves will be the ``remote  
master'' for that cluster..  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_get_cluster_ids(start,end)      
int *start; 
int *end; 
</tt></pre> 
  
receives pointers to two integers.  It places the p4-assigned id's of  
the first and last id's within the current cluster into the two  
arguments (including the remote master).  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_get_my_cluster_id() 
</tt></pre> 
  
returns a unique id (relative to 0) within a cluster of p4-managed  
processes.  Thus, a cluster master will always have a cluster id of 0.  
It is not clear that a separate cluster id is really useful, but the  
functionality is provided just in case.  
<P>
  
<BR> 
<pre> 
<tt> 
BOOL p4_am_i_cluster_master() 
</tt></pre> 
  
returns a BOOL value indicating whether the invoking process is the  
``cluster master'' process within its cluster.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_num_cluster_ids() 
</tt></pre> 
  
returns an integer value indicating the number of ids in the current  
cluster as started by <tt>p4_create_procgroup</tt>.    
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_cluster_shmem_sync(cluster_shmem) 
VOID **cluster_shmem; 
</tt></pre> 
  
This routine is used to synchronize the processes in a cluster before they  
begin to use shared memory.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_get_cluster_masters(numids, ids) 
int *numids, ids[]; 
</tt></pre> 
  
This procedure fills in the values of <tt>numids</tt> and <tt>ids</tt>.  
It obtains the p4-id's of all ``cluster masters'' for the program, placing  
them in the <tt>ids</tt> array and placing the number of id's in <tt>numids</tt>.  
<P>
 <P>
<HR><H1><A NAME="Node23">Functions for Message Passing</a></H1>
<A HREF="p4.html#Node22"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node24"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node24"> Explicit Sending and Receiving of Messages</a>
<b>Previous: </b><A HREF="p4.html#Node22"> Functions for Cluster Management</a>
<P>
  
<P>
P4 supports a set of send/receive procedures.  These procedures are  
``generic'' in the sense that they do not know whether a message must  
travel across a network or through shared memory, or via some other  
mechanism.  They depend on a lower-level set of procedures that handle  
local or network (remote) communications.  By default, the messages  
are assumed to be typed.  If the user wishes to use untyped messages,  
he can hide the typing by coding some very simple C macros that always  
use a single message type.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node24">Explicit Sending and Receiving of Messages</a></H2>
<A HREF="p4.html#Node23"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node23"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node25"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node23"> Functions for Message Passing</a>
<b>Next: </b><A HREF="p4.html#Node25"> Global Operations</a>
<b>Previous: </b><A HREF="p4.html#Node23"> Functions for Message Passing</a>
<P>
  
  
  
  
  
  
  
  
  
<BR> 
<pre> 
<tt> 
p4_send(type,to,msg,len) 
p4_sendr(type,to,msg,len) 
p4_sendx(type,to,msg,len,datatype) 
p4_sendrx(type,to,msg,len,datatype) 
p4_sendb(type,to,msg,len) 
p4_sendbr(type,to,msg,len) 
p4_sendbx(type,to,msg,len,datatype) 
p4_sendbrx(type,to,msg,len,datatype) 
<P>
int type, to, len, datatype; 
char *msg; 
</tt></pre> 
  
<P>
Each of these procedures sends a message.  The <tt>type</tt> argument is an  
integer value chosen by the user to represent a message type.  The <tt>to</tt>  
argument is an integer value that specifies the p4-id of the process that  
should receive the message.  The <tt>len</tt> argument contains the length in  
bytes of the message to be passed.  Note that some of the procedures have a  
``b'' in their name, e.g.  <tt>p4_sendb</tt>.  These procedures assume that the  
msg is in a buffer that the user obtained earlier via a <tt>p4_msg_alloc</tt>;  
otherwise, the buffer is assumed to be in the user's local space, and may  
cause the message to be copied internally.  The procedures with an ``r'' in  
the name do not return until an acknowledgement is received from the <tt>to</tt>  
process (the ``r'' stands for rendezvous).  Those procedures with an ``x'' in  
the name take an extra argument (datatype) that specifies the type of data in  
the message; these procedures will use that information to call XDR for data  
conversion if the message is being passed to a machine of a different  
architecture, i.e. where the internal representation may be different.  The  
valid values for the <tt>datatype</tt> parameter are <tt>P4INT</tt>,  
<tt>P4DBL</tt>, <tt>P4FLT</tt>, <tt>P4LNG</tt>, and <tt>P4NOX</tt>.  The last of  
these means ``no translation''.  
<P>
  
<BR> 
<pre> 
<tt> 
BOOL p4_messages_available(req_type,req_from) 
int *req_type,*req_from; 
</tt></pre> 
  
returns a BOOL value indicating whether the process has any messages available  
or not.  The parameters <tt>req_type</tt> and <tt>req_from</tt> are both pointers  
to integers; they are used as <em> both</em> input and output arguments.  On input,  
<tt>req_type</tt> has a value that indicates the type of message that the user  
wishes to check for availability (-1 indicates any type).  The variable  
<tt>req_from</tt> is used similarly to indicate who a message is desired from.  
<P>
   
<BR> 
<pre> 
<tt> 
int p4_recv(req_type,req_from,msg,len_rcvd) 
int *req_type,*req_from,*len_rcvd; 
char **msg; 
</tt></pre> 
  
takes four arguments.  The <tt>msg</tt> argument is a pointer to a  
pointer to a <tt>char</tt>.  If this value is NULL, then p4 will allocate the  
buffer for the message according to its length.  That is, one need not know  
ahead of time the length of a message being received.  If this value is not  
NULL, then it points to a p4 message buffer that the user has obtained via  
<tt>p4_msg_alloc</tt>.  The <tt>len_rcvd</tt> argument is a pointer to an integer  
that is assigned the length of the received message.  <tt>Req_type</tt> and  
<tt>req_from</tt> are both pointers to integers; they are used as both input and  
arguments.  On input, <tt>req_type</tt> has a value that indicates the type of  
message that the user wishes to receive (-1 indicates any type).  It will  
block until a message of that type is available.  <tt>Req_from</tt> is used  
similarly to indicate who a message is desired from.  One important note about  
this procedure is that it obtains the area in which to place a message, and  
the user must explicitly free that area when finished with it (see  
<tt>p4_msg_free</tt>).  There is an option available with <tt>p4_recv</tt> in  
which the user can provide his own buffer rather than having p4 allocate it.  
To do this, the user points <tt>msg</tt> to a buffer that he must obtain via a  
call to <tt>p4_msg_alloc</tt> (see below).  No <tt>p4_msg_free</tt> should  
be performed if the same buffer is going to be re-used multiple times.  
<P>
  
  
<BR> 
<pre> 
<tt> 
char *p4_msg_alloc(len) 
int len; 
</tt></pre> 
  
  
<BR> 
<pre> 
<tt> 
VOID p4_msg_free(m) 
char *m; 
</tt></pre> 
  
<P>
obtain and free a buffer area that can be used to receive a   
message.  This procedure should be used for this task because a   
message has hidden information which the user is unaware of and   
therefore should not use <tt>malloc</tt> to obtain the area.  
<P>
 <P>
<HR><H2><A NAME="Node25">Global Operations</a></H2>
<A HREF="p4.html#Node24"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node23"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node26"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node23"> Functions for Message Passing</a>
<b>Next: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<b>Previous: </b><A HREF="p4.html#Node24"> Explicit Sending and Receiving of Messages</a>
<P>
  
<P>
P4 supports a number of operations for dealing with all processes at once.  
<P>
  
<BR> 
<pre> 
<tt> 
p4_broadcast(type, data, data_len) 
int type; 
char *data; 
int data_len; 
</tt></pre> 
  
<BR> 
<pre> 
<tt> 
p4_broadcastx(type, data, data_len, data_type) 
int type; 
char *data; 
int data_len, data_type; 
</tt></pre> 
  
provide the ability to broadcast messages like <tt>p4_send</tt> and  
<tt>p4_sendx</tt>.  These are semantically equivalent to a loop which uses  
<tt>p4_send</tt> or <tt>p4_sendx</tt> to individually send a message to each other  
process (the sender is not included.)  Messages sent by one of these  
broadcasts are received by normal <tt>p4_recv</tt>'s.  The implementation of  
<tt>p4_broadcast</tt> is more efficient than such a loop, since it uses a  
``broadcast tree''.  One situation to look out for is a normal  
<tt>p4_broadcast</tt> followed by a <tt>p4_send</tt>.  It is possible for the first  
message to arrive at its destination <em> after</em> the second one.  The order  
of messages in this situation can be enforced with the use of the <tt>type</tt>  
argument.   
<P>
  
<BR> 
<pre> 
<tt> 
p4_global_op(type,x,nelem,size,op,data_type)  
int type; 
char *x; 
int size, nelem; 
int (*op)(); 
int data_type; 
</tt></pre> 
  
where <tt>op</tt> is one of:  
<BR> 
<pre> 
<tt> 
p4_int_absmax_op() 
p4_int_absmin_op() 
p4_int_max_op() 
p4_int_min_op() 
p4_int_mult_op() 
p4_int_sum_op() 
p4_dbl_absmax_op() 
p4_dbl_absmin_op() 
p4_dbl_max_op() 
p4_dbl_min_op() 
p4_dbl_mult_op() 
p4_dbl_sum_op() 
p4_flt_absmax_op() 
p4_flt_absmin_op() 
p4_flt_max_op() 
p4_flt_min_op() 
p4_flt_mult_op() 
p4_flt_sum_op() 
</tt></pre> 
  
and <tt>data_type</tt> is one of <tt>P4INT</tt>, <tt>P4LNG</tt>, <tt>P4FLT</tt>, or  
<tt>P4DBL</tt>.  
<P>
This collection of routines provide the ability to do a variety of global  
operations.  See the example program <em>p4/messages/systest.c</em>.  They apply  
the commutative and associative operation <tt>op</tt> globally to <tt>x</tt> on an  
element-by-element basis and broadcast the result to all nodes.  That is, each  
process ends up with  
<P>
<BR> 
<pre> 
<tt> 
   for (i=0; i&lt;n; i++) 
         x[i] = x[node 0][i] op x[node 1][i] op x[node 2][i] op ... 
</tt></pre> 
  
<tt>op</tt> should be of the form  
<P>
<BR> 
<pre> 
<tt> 
     VOID op(char *x, char *y, int nelem) 
     { 
         data_type *a = (data_type *) x; 
         data_type *b = (data_type *) y; 
<P>
while (nelem--) 
             *a++ operation= *b++; 
     } 
</tt></pre> 
  
where <tt>data_type</tt> and <tt>operation</tt> are chosen appropriately.  
<P>
The order in which nodes apply the operation is undefined (hence <tt>op</tt>  
must be commutative and associative). The communication may be internally  
sub-blocked so the function <tt>op</tt> should not be hardwired to specific  
vector lengths.  
<P>
This is still a relatively primitive version, which gathers the necessary data  
up a balanced binary tree and then uses <tt>p4_broadcast</tt> to send the  
results back.  The <tt>type</tt> argument specifies the message type to be used  
in the communication associated with this global operation.  
<P>
Strictly speaking, the <tt>size</tt> parameter, which is size in bytes of one  
element, is unnecessary.  It is retained for backward compatibility.  
<P>
  
  
<BR> 
<pre> 
<tt> 
VOID p4_global_barrier(type) 
int type; 
</tt></pre> 
  
This procedure takes one argument which is the message type to be   
used for internal message-passing.  It causes the invoking process to  
hang until all processes specified in the procgroup file have invoked   
the procedure.  
<P>
 <P>
<HR><H1><A NAME="Node26">Functions for Shared Memory</a></H1>
<A HREF="p4.html#Node25"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node27"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node27"> Managing Shared and Local Memory</a>
<b>Previous: </b><A HREF="p4.html#Node25"> Global Operations</a>
<P>
  
  
<P>
Here is a simple example of a shared-memory program using monitors.  In this  
program, each process retrieves values from a shared loop index.  A  
<em>monitor</em> is used to ensure that all values are retrieved exactly once.  
<P>
<BR> 
<pre> 
<tt> 
#include "p4.h" 
<P>
struct globmem { 
    p4_getsub_monitor_t getsub; 
} *glob; 
<P>
main(argc,argv) 
int  argc; 
char **argv; 
{ 
    p4_initenv(&amp;argc,argv); 
<P>
glob = (struct globmem *) p4_shmalloc(sizeof(struct globmem)); 
    p4_getsub_init(&amp;(glob-&gt;getsub)); 
<P>
p4_create_procgroup(); 
    worker(); 
    p4_wait_for_end(); 
} 
<P>
worker() 
{ 
    int i, nprocs; 
<P>
nprocs = p4_num_total_ids(); 
    i = 0; 
    while (i &gt;= 0) 
    { 
        p4_getsub(&amp;(glob-&gt;getsub),&amp;i,10,nprocs); 
        p4_dprintf("I got %d\n",i); 
    } 
} 
<P>
</tt></pre> 
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node27">Managing Shared and Local Memory</a></H2>
<A HREF="p4.html#Node26"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node26"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node28"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<b>Next: </b><A HREF="p4.html#Node28"> Shared Memory Data Types</a>
<b>Previous: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<P>
The following functions are just basic memory management routines.  
<P>
  
<BR> 
<pre> 
<tt> 
char *p4_malloc(n) 
int n; 
</tt></pre> 
  
typically acts like the standard <tt>malloc</tt>, but may be rewritten for user   
systems that require different operation.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_free(p) 
char *p; 
</tt></pre> 
  
typically acts like the standard <tt>free</tt>, but may be rewritten for  
user systems that require different operation.  
<P>
  
<BR> 
<pre> 
<tt> 
char *p4_shmalloc(n) 
int n; 
</tt></pre> 
  
acts like the standard <tt>malloc</tt> except will obtain shared memory on  
machines that support sharing memory among processes.  Compare with  
<tt>p4_malloc</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_shfree(p) 
char *p; 
</tt></pre> 
  
frees memory obtained with <tt>p4_shmalloc</tt>.  Compare with <tt>p4_free</tt>.  
<P>
 <P>
<HR><H2><A NAME="Node28">Shared Memory Data Types</a></H2>
<A HREF="p4.html#Node27"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node26"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node29"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<b>Next: </b><A HREF="p4.html#Node29"> Monitor-Building Primitives</a>
<b>Previous: </b><A HREF="p4.html#Node27"> Managing Shared and Local Memory</a>
<P>
  
  
  
<P>
The abstraction provided by p4 for managing data in shared memory is  
<em>monitors</em>.  Good places to learn about the monitor concept in general are  
[(ref pbh:architecture)] and [(ref hoare:monitors)].  The specific approach  
taken by p4 is described in [(ref lusk-overbeek:p4-book)].  P4 provides several  
useful monitors (<tt>p4_barrier_t</tt>, <tt>p4_getsub_monitor_t</tt>,  
<tt>p4_askfor_monitor_t</tt>) as well as a general monitor type to help the user  
in constructing his own monitors (<tt>p4_monitor_t</tt>).  
<P>
 <P>
<HR><H2><A NAME="Node29">Monitor-Building Primitives</a></H2>
<A HREF="p4.html#Node28"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node26"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node30"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<b>Next: </b><A HREF="p4.html#Node30"> Some Useful Monitors</a>
<b>Previous: </b><A HREF="p4.html#Node28"> Shared Memory Data Types</a>
<P>
  
<P>
The following functions can be used to construct monitors.  A monitor so  
constructed has the type <tt>p4_monitor_t</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_moninit(m,i) 
p4_monitor_t *m; 
int i; 
</tt></pre> 
  
initializes the monitor pointed to by <tt>m</tt> and gives it <tt>i</tt>  
queues for processes to wait on while they are blocked (see <tt>p4_mdelay</tt>).  
One queue is sufficient for most purposes.  The queues are numbered beginning  
with 0.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_menter(m) 
p4_monitor_t *m; 
</tt></pre> 
  
enter the monitor pointed to by <tt>m</tt>.  By the definition of a monitor,  
access is restricted to a single process in the monitor at a time (if  
everybody plays by the rules).  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_mexit(m) 
p4_monitor_t *m; 
</tt></pre> 
  
exits the monitor pointed to by <tt>m</tt>.  You are of course assumed to have  
previously entered that monitor.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_mcontinue(m,i) 
p4_monitor_t *m; 
int i; 
</tt></pre> 
  
checks to see if there are any processes blocked on the <tt>i</tt>-th queue of  
the monitor <tt>m</tt> and causes one of them to be released for entry to the  
monitor if so.  If there are no such processes, the invoking process  
simply exits.  Note that a process could have been blocked previously  
by invoking the procedure <tt>p4_mdelay</tt>.  The queues are numbered   
beginning with 0.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_mdelay(m,i) 
p4_monitor_t *m; 
int i; 
</tt></pre> 
  
permits a process to delay itself on the <tt>i</tt>-th queue of monitor  
<tt>m</tt> if the process wishes to release the monitor, but wants to be  
waked up by another process later (via the procedure <tt>p4_mcontinue</tt>).  
The queues are numbered beginning with 0.  
<P>
 <P>
<HR><H2><A NAME="Node30">Some Useful Monitors</a></H2>
<A HREF="p4.html#Node29"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node26"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node31"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node26"> Functions for Shared Memory</a>
<b>Next: </b><A HREF="p4.html#Node31"> Functions for Timing p4 Programs</a>
<b>Previous: </b><A HREF="p4.html#Node29"> Monitor-Building Primitives</a>
<P>
  
<P>
In this section we describe some of the specific monitors that are built into  
the p4 library.  Each of them has its own pre-defined type, which can be  
used to allocate storage for them, which should be in shared memory.  
See the <em>p4/monitors</em> directory for examples.  A lock is itself a  
monitor, with no extra delay queues.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_lock_init(l) 
p4_lock_t *l; 
</tt></pre> 
  
initializes the lock <tt>l</tt>.  Must be used prior to any attempts to lock or  
unlock <tt>l</tt>.  
<P>
  
  
<BR> 
<pre> 
<tt> 
VOID p4_lock(l) 
p4_lock_t *l; 
</tt></pre> 
  
blocks if the lock <tt>l</tt> is already locked, otherwise locks <tt>l</tt>  
and proceeds.  
<P>
  
  
<BR> 
<pre> 
<tt> 
VOID p4_unlock(l) 
p4_lock_t *l; 
</tt></pre> 
  
unlocks the lock <tt>l</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_getsub(gs,s,max,nprocs) 
p4_getsub_monitor_t *gs; 
int *s,max,nprocs; 
</tt></pre> 
  
is a procedure used to obtain the next value of a shared counter  
(subscript).  It takes as its first argument, a pointer to a getsub  
monitor that protects the shared counter.  It assigns the current value  
of the counter to the integer that s points to, and then increments the  
counter by 1.  <tt>p4_getsub_init</tt> initially sets the counter to 0.  
When the counter passes the value <tt>max</tt>, all <tt>nprocs</tt>  
processes are returned the value (-1) once, then the counter is reset to  
0 for further use.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_getsubs(gs,s,max,nprocs,stride) 
p4_getsub_monitor_t *gs; 
int *s,max,nprocs,stride; 
</tt></pre> 
  
is like <tt>p4_getsub</tt> except that the counter is increased on each call by  
<tt>stride</tt> instead of 1.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_getsub_init(gs) 
p4_getsub_monitor_t *gs; 
</tt></pre> 
  
initializes the getsub monitor pointed to by <tt>gs</tt>; this initialization  
includes assigning a value of 0 to the counter that the monitor  
protects.  
<P>
The standard barrier synchronization pattern is expressed as a monitor.  
There can be multiple barrier monitors, and one can wait for only some  
of the processes at the barrier if this is desired.  
<P>
  
  
<BR> 
<pre> 
<tt> 
VOID p4_barrier(b,nprocs) 
p4_barrier_monitor_t *b; 
int nprocs; 
</tt></pre> 
  
causes the executing process to hang until <tt>nprocs</tt> processes execute  
a barrier instruction with a pointer to the same barrier monitor <tt>b</tt>  
as an argument.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_barrier_init(b) 
p4_barrier_monitor_t *b; 
</tt></pre> 
  
initializes the barrier monitor <tt>b</tt>; this procedure should be invoked  
before you attempt to use the monitor in any operations.  
<P>
Finally, the <tt>askfor</tt> monitor functions like a general dispatcher of  
work.   
<P>
  
  
<BR> 
<pre> 
<tt> 
int p4_askfor(af,nprocs,getprob_fxn,problem,reset_fxn) 
p4_askfor_monitor_t *af; 
int nprocs; 
int (*getprob_fxn)(); 
VOID *problem; 
int (*reset_fxn)(); 
</tt></pre> 
  
requests a new ``problem'' to work on from the problem pool.  The  
arguments are (1) a pointer to the askfor monitor that protects the  
problem pool, (2) the number of processes that call this procedure  
(with <tt>af</tt>) looking for work, (3) a pointer to the user-written procedure  
that obtains a problem from the pool, (4) a pointer that is filled in  
with the address of a user-defined representation of a problem to be  
solved, and (5) a pointer to a user-written procedure to reset when all  
problems in the pool are solved, in case the same monitor is re-used  
for another set of problems later.  <tt>p4_askfor</tt> returns an integer  
indicating whether a problem was successfully obtained or not:  
<P>
<BR> 
<pre> 
<tt> 
  -1     : program is terminating (some process called p4_progend) 
   0     : a problem was obtained and ``problem'' points to it 
   1     : problem solved by exhaustion, i.e. no more problems to get 
   n &gt; 1 : a process found a solution and called p4_probend with code n 
</tt></pre> 
  
For a detailed discussion of the ``askfor'' monitor, see  
[(ref lusk-overbeek:p4-book)].  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_update(af,putprob_fxn,problem) 
p4_askfor_monitor_t *af; 
int (*putprob_fxn)(); 
VOID *problem; 
</tt></pre> 
  
updates the problem pool being managed by the askfor monitor.  The  
arguments are (1) a pointer to the askfor monitor that protects the  
problem pool, (2) a pointer to the user-written procedure that puts  
problems into the pool, and (3) a pointer to a user-defined  
representation of a problem to be put in the pool.  <tt>Putprob_fxn</tt>  
should return 1 if it did indeed put a new problem into the pool, so  
that any delayed processes should wake up and re-examine the pool (this  
logic is handled by the <tt>p4_askfor</tt>) and 0 if upon entering the  
monitor and examining its potential problem together with the data there  
it decided not to add a new problem to the pool.  It can be assumed that  
the ``putprob'' logic (defined by <tt>putprob_fxn</tt>) is executed inside  
the monitor.  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_askfor_init(af) 
p4_askfor_monitor_t *af; 
</tt></pre> 
  
initializes the askfor monitor <tt>af</tt>; this procedure should be invoked  
before you attempt to use the monitor in any operations.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_probend(af,code) 
p4_askfor_monitor_t *af; 
int code; 
</tt></pre> 
  
allows the user process to mark a problem as solved early when  
several processes are coordinating their activities via an askfor  
monitor.  The code is an integer value that will be returned to all  
processes when they ``askfor'' a new sub-problem to work on.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_progend(af) 
p4_askfor_monitor_t *af; 
</tt></pre> 
  
allows a process to cause a return code of (-1) to be returned to all  
processes using an askfor monitor.  This would typically be called by  
a master process to indicate that no more problems are to be solved  
and that all slave processes should terminate.  
<P>
 <P>
<HR><H1><A NAME="Node31">Functions for Timing p4 Programs</a></H1>
<A HREF="p4.html#Node30"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node32"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node32"> Functions for Debugging p4 Programs</a>
<b>Previous: </b><A HREF="p4.html#Node30"> Some Useful Monitors</a>
<P>
  
  
A small number of simple functions are available for accessing various  
clocks and timers.    
<P>
  
<BR> 
<pre> 
<tt> 
int p4_clock() 
</tt></pre> 
  
returns a value in milliseconds.  This is a wall-clock value, usually obtained  
from the system via <tt>gettimeofday</tt>.  Also see <tt>p4_ustimer</tt> below.  
<P>
  
<BR> 
<pre> 
<tt> 
p4_usc_time_t p4_ustimer() 
</tt></pre> 
  
returns a wall-clock time value in microseconds.  The precision of this  
number depends on the timer installed on the individual machine.  In  
some cases the resolution may be no greater than that of <tt>p4_clock()</tt>.  
For arithmetic and printing purposes, the type <tt>p4_usc_time_t</tt> is an  
unsigned long integer.  
<P>
  
<BR> 
<pre> 
<tt> 
p4_usc_time_t p4_usrollover() 
</tt></pre> 
  
returns the timer value at which a microsecond timer ``rolls over''.  
Since <tt>p4_usc_time_t</tt> is a long integer's worth of microseconds, it is  
likely that the timer will roll over (become zero) during even  
medium-length runs (about 72 minutes on most machines).  
<P>
 <P>
<HR><H1><A NAME="Node32">Functions for Debugging p4 Programs</a></H1>
<A HREF="p4.html#Node31"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node33"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node33"> Miscellaneous Functions</a>
<b>Previous: </b><A HREF="p4.html#Node31"> Functions for Timing p4 Programs</a>
<P>
  
<P>
P4 has a set of routines to aid in producing a printed trace of events, both  
user-defined and pre-defined in the p4 system.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_dprintf(fmt, va_alist) 
char *fmt; 
va_dcl 
</tt></pre> 
  
acts just like the standard <tt>printf</tt> except that the print line is  
preceded by a value that identifies the process.  This value is  
typically the string <tt>pn_u</tt> where <tt>n</tt> represents the  
p4-assigned id and <tt>u</tt> represents the unix-id of the process on its  
host.  However, there are other forms of this value.  For example, the  
big master is represented as <tt>bm_u</tt>.  Also, if a process prints  
before it has a p4-assigned id, then its value will be something like  
<tt>bm_slave_n_u</tt> or <tt>rm_slave_n_u</tt>.  Typically, it is not  
possible for a user program to print anything before being assigned an  
id by p4, but the p4 system itself may use this procedure to print  
messages from a particular process if it encounters problems getting the  
process initialized.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_dprintfl(level, fmt, va_alist) 
int level; 
char *fmt; 
va_dcl 
</tt></pre> 
  
is like <tt>p4_dprintf</tt> except that the first argument is an integer  
indicating the debugging level that must be in effect before this  
message will print.  A level of 0 will cause the message to always print.  
If you run a program with the debug level set to 5 (via command-line  
arguments), then all <tt>dprintfl</tt>'s with level less than or equal to  
that debug level will print. See section <a href="p4.html#Node16">Command-Line Arguments</a> for how to  
set the debug level at run time.  
<P>
The debug level can be examined and changed by the user during execution:  
<P>
  
<BR> 
<pre> 
<tt> 
int p4_get_dbg_level()      
</tt></pre> 
  
returns the current debug level for this process and its cluster.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_set_dbg_level(level)      
int level; 
</tt></pre> 
  
sets the current debug level for this process and its cluster.  
P4 itself is liberally instrumented with <tt>p4_dprintfl</tt>'s of level  
10 and above, leaving levels 0-9 for the user.  The greater the debug  
level of the built-in messages, the greater understanding of p4 needed  
by the user to make sense of them.  However, levels as high as 30 may  
well be useful to the user trying to debug a p4 program.  
Roughly speaking, the following debug levels produce messages about the  
indicated events.  
<P>
<BR> 
<pre> 
<tt> 
level 10:  created process 
           sent message 
           received message 
<P>
level 20:  creating process 
           sending message 
           receiving message 
           process starting 
           process exiting 
<P>
level 30:  waiting for ack 
           sending ack 
           sent ack 
           received ack 
           queueing message for later receipt 
           queued message for later receipt 
<P>
level 40:  memory management 
           buffer management 
<P>
level 50:  reading procgroup 
           other initialization message exchange 
<P>
level 60:  send-receive details, especially machine-specific traces 
<P>
level 70:  listener interactions: 
            creating listener 
            created listener 
            messages from inside listener 
<P>
level 80:  detailed data structures after initialization 
<P>
level 90:  detailed tracing of flow thru procedures 
</tt></pre> 
For optimum performance, the test of the debug level required by these  
messages can be removed at compile time by not commenting out the   
<tt>#define P4_DPRINTFL</tt> line in the <em>OPTIONS</em>  
file (See section <a href="p4.html#Node1">Introduction</a>).  
<P>
The following function is provided to deal with abnormal termination.  
It can be called by any process.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_error(string, value) 
char *string; 
int value; 
</tt></pre> 
  
prints <tt>string</tt> as an error message and then forcefully terminates  
all co-operating processes and cleans up all shared resources.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_soft_errors(onoff)      
int onoff; 
</tt></pre> 
  
enables/disables soft errors, returning the previous setting.  The default  
is ``disabled'', which means that certain p4 functions will call  
<tt>p4_error</tt> instead of returning -1.  
<P>
  
<tt>p4_error</tt> gets control on certain kinds of interrupts.  It is  
automatically called for <tt>SIGSEGV</tt>, <tt>SIGBUS</tt>, and <tt>SIGFPE</tt>  
interrupts, to catch user programming errors and clean up, after which it  
returns interrupt handling to default mode and returns, so that the user  
may obtain a dump.  It also handles <tt>SIGINT</tt> interrupts, in which case  
it cleans up and exits.  Finally, it may be called directly by the user, in  
which case it cleans up (other p4 processes and IPC's) and exits.  
<P>
  
Although <tt>p4_error</tt> is supposed to get rid of all running p4  
processes, it can happen that an error is bad enough that p4 processes  
are left running.  A primitive aid in finding and killing these  
processes is the shell script <tt>kj</tt>, which takes a string as an  
argument and then kills processes containing that string as part of  
their program names.  Currently it only kills processes on the machine  
where it is run, but it can be run via <tt>rsh</tt> on remote machines.  
There are other useful scripts (e.g. <tt>killipc</tt> and <tt>killp4</tt>)  
in the <em>p4/bin</em> directory to do such things as clean up SYSV IPC   
items that may be left when a program abnormally terminates.  P4 will   
generally cleanup these items if the abnormal termination is a type that   
p4 traps, otherwise the user must do the cleanup.  This is an unfortunate  
side-effect of the way that SYSV handles things, it really should be  
the OS's function to take care of this.  
<P>
On many machines it is possible to attach a debugger like <tt>dbx</tt> to a  
running process.  This is one way to find out where a hanging process is  
stuck.   
<P>
 <P>
<HR><H1><A NAME="Node33">Miscellaneous Functions</a></H1>
<A HREF="p4.html#Node32"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node34"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node34"> Fortran Interface</a>
<b>Previous: </b><A HREF="p4.html#Node32"> Functions for Debugging p4 Programs</a>
<P>
In this section are found functions that do seem to fit neatly into any of the  
other sections.  
<P>
  
<BR> 
<pre> 
<tt> 
char *p4_version() 
</tt></pre> 
  
returns a string containing the version number of p4 being run.  
<P>
  
<BR> 
<pre> 
<tt> 
VOID p4_print_avail_buffs() 
</tt></pre> 
P4 maintains an array of buffer lists of various sizes, so that it can very  
rapidly allocate and deallocate buffers.  You can see the contents of the  
buffer pools at any time by calling this procedure.  
<P>
  
  
<BR> 
<pre> 
<tt> 
VOID p4_set_avail_buff(bufidx,size) 
int bufidx; 
int size; 
</tt></pre> 
  
This procedure is used to set the size of buffers in p4's buffer pools.  The  
parameter <tt>bufidx</tt> specifies a particular buffer list, and should be a  
number from 0 to 7.  The <tt>size</tt> parameter specifies that buffers up to  
that size will be managed by p4 in a particular list.  It is important to  
maintain the buffer sizes in increasing order.  The default list of buffer  
sizes is 64, 256, 1024, 4096, 16384, 65536, 262144, 1048576.  This causes  
wasted space if you send only one large message, causing the allocation of a  
large buffer which is not reused.  Savings in space can be achieved by  
adjusting these numbers to correspond with the message sizes of your  
application.  If no large messages are sent at all, however, no space is  
wasted since the large buffers will never be allocated.  If you send a message  
larger that the largest size in this array, p4 will allocate the buffer, and  
then free it back to the system as soon as it can.  
<P>
 <P>
<HR><H1><A NAME="Node34">Fortran Interface</a></H1>
<A HREF="p4.html#Node33"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node35"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node35"> Faster Startup with the Secure Server</a>
<b>Previous: </b><A HREF="p4.html#Node33"> Miscellaneous Functions</a>
<P>
  
<P>
In this section we describe the p4 Fortran library.  All Fortran programs must  
include the file <em>p4f.h</em> from the directory <em>lib_f</em>.  The Fortran  
calls to p4 procedures are analogous to their C counterparts, but have  
Fortran-like names.  You might find the documentation for the corresponding C  
routine, in one of the sections above, helpful.  
<P>
  
<BR> 
<pre> 
<tt> 
p4init() 
</tt></pre> 
  
should be called by your program before an attempt is made to use  
any p4 procedures or data areas.  We suggest making it the first executable  
statement in your program.  
<P>
  
<BR> 
<pre> 
<tt> 
p4crpg() 
</tt></pre> 
  
This routine should be called by the master process (the one started directly  
by you) to read the procgroup file and start the processes specified there.  
It can be called by other process, but has no effect in that case.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4myid() 
</tt></pre> 
  
returns an integer value representing the id of the process assigned by  
the p4 system.  
<P>
  
<BR> 
<pre> 
<tt> 
p4cleanup() 
</tt></pre> 
  
should be called by the master process to wait for the termination of the  
processes created by <tt>p4crpg</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
p4send(type,dest,msg,len,rc) 
integer type, dest, len, rc 
real msg 
</tt></pre> 
  
<P>
  
<BR> 
<pre> 
<tt> 
p4sendx(type,dest,msg,len,data_type,rc) 
integer type, dest, len, data_type, rc 
real msg 
</tt></pre> 
  
<P>
  
<BR> 
<pre> 
<tt> 
p4sendr(type,dest,msg,len,rc) 
integer type, dest, len, rc 
real msg 
</tt></pre> 
  
<P>
  
<BR> 
<pre> 
<tt> 
p4sendrx(type,dest,msg,len,data_type,rc) 
integer type, dest, len, data_type, rc 
real msg 
</tt></pre> 
  
Each of these procedures sends a message.  The <tt>type</tt> argument  
is an integer value chosen by the user to represent a message type.  The  
<tt>dest</tt> argument is an integer value that specifies the p4-id of the  
process that should receive the message.  The <tt>len</tt> argument contains the  
length in bytes of the message to be sent.  The procedures with an ``r'' in  
the name do not return until an acknowledgement is received from the <tt>to</tt>  
process (the ``r'' stands for rendezvous).  Those procedures with an ``x'' in  
the name take an extra argument (datatype) that specifies the type of data in  
the message; these procedures will use that information to call XDR for data  
conversion if the message is being passed to a machine of a different  
architecture, i.e. where the internal representation may be different.  p4  
maintains an internal table of which pairs of machine types require  
conversion, so it only does the conversion when it is necessary.  The valid  
values for the <tt>data_type</tt> parameter are <tt>P4INT</tt>, <tt>P4DBL</tt>,  
<tt>P4FLT</tt>, <tt>P4LNG</tt>, and <tt>P4NOX</tt>.  The last of these means ``no  
translation''.  
<P>
  
<BR> 
<pre> 
<tt> 
p4recv(type,from,buf,buflen,msglen,rc) 
integer type, from, buflen, msglen, rc 
real buf 
</tt></pre> 
  
The <tt>buf</tt> parameter is the buffer into which the message is to  
be received.  It can be of any Fortran type.  The <tt>buflen</tt> parameter  
specifies its length, so that p4 can check for overruns.  The number of bytes  
actually received is given by <tt>msglen</tt>.  The <tt>type</tt> and <tt>from</tt>  
parameters specify the message type and the source of the message.  If either  
of these is set to -1, then screening is not applied, and the parameter is set  
to indicate the type and/or source of the message actually received.  
<tt>rc</tt> is the return code from the call.  
<P>
  
<BR> 
<pre> 
<tt> 
p4probe(type,from,rc) 
</tt></pre> 
  
sets <tt>rc</tt> to 1 or 0 depending on whether the process has any  
messages available or not.  The parameters <tt>type</tt> and <tt>from</tt> are  
used as <em> both</em> input and arguments.  On input, <tt>type</tt> has a value  
that indicates the type of message that the user wishes to check for  
availability (-1 indicates any type).  The variable <tt>from</tt> is used  
similarly to indicate who a message is desired from.  
<P>
  
<BR> 
<pre> 
<tt> 
p4brdcst(type,data,len,rc) 
integer type, len, rc 
real data 
</tt></pre> 
  
<BR> 
<pre> 
<tt> 
p4brdcstx(type,data,len,data_type,rc) 
integer type, len, data_type, rc 
real data 
</tt></pre> 
  
provide the ability to broadcast messages like <tt>p4send</tt> and  
<tt>p4sendx</tt>.  These are semantically equivalent to a loop which uses  
<tt>p4send</tt> or <tt>p4sendx</tt> to individually send a message to each  
other process (the sender is not included.)  Messages sent by one of these  
broadcasts are received by normal <tt>p4recv</tt>'s.  The implementation of   
<tt>p4brdcst</tt> is more efficient than such a loop, since it uses a  
``broadcast tree''.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4ntotids() 
</tt></pre> 
  
returns an integer value indicating the total number of processes started  
by the p4 master process and all remote processes.  It includes the master  
process itself.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4nslaves() 
</tt></pre> 
  
returns an integer value indicating the total number of processes started  
by p4, not including the original master process.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4nclids() 
</tt></pre> 
  
returns an integer value indicating the number of ids in the current  
cluster as started by <tt>p4crpg</tt>.    
<P>
  
<BR> 
<pre> 
<tt> 
integer p4myclid() 
</tt></pre> 
  
returns a unique id (relative to 0) within a cluster of p4-managed  
processes.  Thus, a cluster master will always have a cluster id of 0.  
<P>
  
<BR> 
<pre> 
<tt> 
p4globarr(type) 
integer type 
</tt></pre> 
  
takes one argument which is the message type to be used for internal  
message-passing.  It causes the invoking process to wait until all processes  
specified in the procgroup file have invoked the procedure.  
<P>
  
<BR> 
<pre> 
<tt> 
p4getclmasts(numids,ids) 
integer numids, ids(*) 
</tt></pre> 
  
This procedure fills in the values of numids and ids.  It obtains the  
p4-ids of all ``cluster masters'' for the program, placing them in the  
ids array and placing the number of ids in numids.  
<P>
  
<BR> 
<pre> 
<tt> 
p4getclids(start,end) 
integer start, end 
</tt></pre> 
  
receives two integers.  It places the p4-assigned id's of  
the first and last ids within the current cluster into the two  
arguments (including the remote master).  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4clock() 
</tt></pre> 
  
returns a value in milliseconds.  This is a wall-clock value, usually obtained  
from the system via <tt>gettimeofday</tt>.  Also see <tt>p4ustimer</tt> below.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4ustimer() 
</tt></pre> 
  
returns a wall-clock time value in microseconds.  The precision of this  
number depends on the timer installed on the individual machine.  In  
some cases the resolution may be no greater than that of <tt>p4clock()</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
p4flush() 
</tt></pre> 
  
flushes standard out.  On some systems this needs to be done explicitly for  
prompts.  This is just a convenience routine that has nothing to do with p4.  
<P>
  
<BR> 
<pre> 
<tt> 
p4error(str,val) 
character*n str 
integer val 
</tt></pre> 
  
prints <tt>string</tt> as an error message and then forcefully terminates  
all p4 processes.  
<P>
  
<BR> 
<pre> 
<tt> 
p4softerrs(new,old) 
integer new, old 
</tt></pre> 
  
enables/disables soft errors, returning the previous setting in  
<tt>old</tt>.  The default is ``disabled'', which means that certain p4  
functions will call <tt>p4_error</tt> instead of returning -1.  
<P>
  
<BR> 
<pre> 
<tt> 
integer p4version() 
</tt></pre> 
  
returns a string containing the version number of p4 being run.  
<P>
  
<BR> 
<pre> 
<tt> 
p4avlbufs() 
</tt></pre> 
  
P4 maintains an array of buffer lists of various sizes, so that it can very  
rapidly allocate and deallocate buffers.  You can see the contents of the  
buffer pools at any time by calling this procedure.  
<P>
  
<BR> 
<pre> 
<tt> 
p4setavlbuf(idx,size) 
integer idx, size 
</tt></pre> 
  
This procedure is used to set the size of buffers in p4's buffer pools.  The  
parameter <tt>bufidx</tt> specifies a particular buffer list, and should be a  
number from 0 to 7.  The <tt>size</tt> parameter specifies that buffers up to  
that size will be managed by p4 in a particular list.  It is important to  
maintain the buffer sizes in increasing order.  The default list of buffer  
sizes is 64, 256, 1024, 4096, 16384, 65536, 262144, 1048576.  This causes  
wasted space if you send only one large message, causing the allocation of a  
large buffer which is not reused.  Savings in space can be achieved by  
adjusting these numbers to correspond with the message sizes of your  
application.  If no large messages are sent at all, however, no space is  
wasted since the large buffers will never be allocated.  If you send a message  
larger that the largest size in this array, p4 will allocate the buffer, and  
then free it back to the system as soon as it can.  
<P>
  
<BR> 
<pre> 
<tt> 
p4globop(type,x,nelem,size,op,data_type,rc) 
</tt></pre> 
  
where <tt>op</tt> is one of:  
<BR> 
<pre> 
<tt> 
   p4intsumop 
   p4intabsmaxop 
   p4intabsminop 
   p4intmaxop 
   p4intminop 
   p4intmultop 
   p4dblsumop 
   p4dblabsmaxop 
   p4dblabsminop 
   p4dblmaxop 
   p4dblminop 
   p4dblmultop 
   p4fltsumop 
   p4fltabsmaxop 
   p4fltabsminop 
   p4fltmaxop 
   p4fltminop 
   p4fltmultop 
</tt></pre> 
The <tt>data_type</tt> parameter in the above operations should be one of  
<BR> 
<pre> 
<tt> 
  P4INT 
  P4LNG 
  P4FLT 
  P4DBL   
</tt></pre> 
  
These symbolic constants are defined in the include file <em>p4f.h</em>.  The  
<tt>size</tt> argument is the size in bytes of one element, and the <tt>type</tt>  
argument is the message type used in the global operation.  
<P>
There are also Fortran routines for creating logfiles  
See section <a href="p4.html#Node39">Creating Log Files in Fortran</a>.  
<P>
 <P>
<HR><H1><A NAME="Node35">Faster Startup with the Secure Server</a></H1>
<A HREF="p4.html#Node34"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node36"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node36"> Utilities for Managing a p4 Session</a>
<b>Previous: </b><A HREF="p4.html#Node34"> Fortran Interface</a>
<P>
  
  
  
  
<P>
P4 processes on remote machines are ordinarily created by <tt>rsh</tt>.  
For this to work, the user must have permission to create processes on  
that machine.  This permission is normally granted either globally by  
the system administrator, or locally by the use of <em>.rhosts</em> files.  
(See the normal unix man pages under <tt>rhosts</tt>).  
<P>
Since <tt>rsh</tt> is relatively slow, p4 provides a way to get things  
started faster.  This is accomplished by running the program  
<tt>serv_p4</tt> in the background on the remote machine.  When p4 is  
creating processes, it will automatically check for the existence of  
this server and use it if it is running.  Remote processes typically  
start much faster when the server is running.   
When p4 uses <tt>rsh</tt>, the remote process's <tt>stdout</tt> is sent  
back to the <tt>stdout</tt> of the parent (the p4 master process).  
We have not yet tested this server on all of the machines that we support.  
Thus far, we have tested it somewhat on the SYMMETRY, SUN, DEC5000, and  
SGI.  We believe that it will work on many other machines, but have not  
yet verified it on all machines.  
<P>
An invocation of a set of servers is (currently) associated with a specific  
port number.  This way multiple users can each be running multiple server  
networks without mutual interference, provided each network of servers is  
started with a different port number.   
<P>
To start the secure server on a machine one can do  
<P>
<BR> 
<pre> 
<tt> 
serv_p4 -d -p &lt;num&gt; 
</tt></pre> 
  
where <tt>&lt;num&gt;</tt> is a port number to be associated with a network of  
servers.  If the <tt>-p</tt> option is omitted, the server will pick an unused  
port number and report  
<P>
<BR> 
<pre> 
<tt> 
Listening on &lt;num&gt;. 
</tt></pre> 
  
Then p4 programs to use this network should be started with   
<P>
<BR> 
<pre> 
<tt> 
-p4ssport &lt;num&gt; 
</tt></pre> 
The p4 application must also be listed in the user's <em>.p4apps</em> file in  
his home directory.  This file should be readable only by the user, and should  
contain the full path names of programs that the user wishes to be startable  
by the p4 server.  
<P>
When a p4 master process tries to start a slave process on a remote machine,  
it will first attempt to do it via the server.  If it cannot do so for any  
reason (no server running, port number mismatch, or program not found in  
<em>.p4apps</em> file), then it tries to do so with the remote shell command.  
<P>
Note that the server is used only to start processes; it plays no role in a p4  
computation once the slave processes have been initiated.  Rather, a temporary  
process, called the <em> listener</em>, is spawned to manage connection requests  
that occur during the execution of a p4 program.  Neither the server nor the  
listener consumes any significant amount of CPU time.  
<P>
There is further discussion of installation options for the servers in  
the <em>README</em> file in the <em>p4/servers</em> subdirectory.  
<P>
 <P>
<HR><H1><A NAME="Node36">Utilities for Managing a p4 Session</a></H1>
<A HREF="p4.html#Node35"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node37"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<b>Previous: </b><A HREF="p4.html#Node35"> Faster Startup with the Secure Server</a>
<P>
  
  
<P>
A number of useful utilities can be found in the <em>bin</em> subdirectory.  
These can be used to start and stop server processes based on the contents of  
a file of machines one regularly uses, to kill runaway p4 processes in the  
unlikely case that they cannot or do not terminate automatically when one  
processes ends abnormally or is interrupted from the keyboard, and to merge  
logfiles created for the use of <tt>upshot</tt> (See section <a href="p4.html#Node37">Creating Logfiles for Upshot</a>).  Some of these scripts may have to be edited to reflect the  
installation directory of p4.  
<P>
<dl> 
 
<dt> 
<b>start_servers</b><dd> 
Use a port number from the command line and afile of  
  machine--program pairs to start a set of secure servers.  
 
<dt> 
<b>kill_servers</b><dd> 
Use the same file to kill a set of secure servers.  
 
<dt> 
<b>killp4</b><dd> 
Kills p4 processes, given a procgroup file and a program name on  
  the local machine.   
 
<dt> 
<b>mergelogs</b><dd> 
A C program to merge logfiles.  Its source code is in the  
  <tt>alog</tt> directory, but the makefile deposits the executable here.  
 
<dt> 
<b>listener_p4</b><dd> 
The code for the standalone listener.  
 
<dt> 
<b>adjlogs</b><dd> 
A C program to line up the timestamps when logs are taken from  
  different machines on a network.  The source is in the <tt>alog</tt>  
  directory, but the executable goes here.  It cannot be made on all machines,  
  because it uses an extended-precision math library.  It works on Suns.  
</dl> 
<BR> 
 <P>
<HR><H1><A NAME="Node37">Creating Logfiles for Upshot</a></H1>
<A HREF="p4.html#Node36"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node38"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node38"> User-Specified Events</a>
<b>Previous: </b><A HREF="p4.html#Node36"> Utilities for Managing a p4 Session</a>
<P>
  
  
  
  
<P>
P4 is distributed with a set of routines for creating logfiles (see  
<em>README</em> in the <em>p4/alog</em> directory.  The resulting logfiles  
can be examined by <tt>upshot</tt>, distributed separately.  For details  
about <tt>upshot</tt>, see [(ref herrarte-lusk:upshot)].    
<P>
The <em>p4/alog</em> directory contains a package (ALOG) for creating logs of  
time-stamped events, that is of general utility, outside of p4.  The  
timestamps are obtained from various microsecond-level resolution timers on  
various machines.  The portable microsecond timing package is contained in the  
<em>usc</em> subdirectory.  It is used by the ALOG package as well as by the  
<tt>p4_ustimer</tt> function in p4.  Similarly, the ALOG package can be used  
independently of p4 and <tt>upshot</tt>. Its logfiles were designed to be read  
and displayed by upshot, but other display packages can be used as well.  
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node38">User-Specified Events</a></H2>
<A HREF="p4.html#Node37"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node37"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node39"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<b>Next: </b><A HREF="p4.html#Node39"> Creating Log Files in Fortran</a>
<b>Previous: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<P>
  
<P>
The ALOG package consists of a set of macros that can be used to instrument a  
C program and a set of functions that can be used to instrument a Fortran  
program.  We will focus here primarily on the use of the C interface, which  
contains more functionality.  
<P>
The macros that can be used to instrument a program are as follows (from the   
file <em>README_ALOG</em> in the <em>alog</em> directory):  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_SETUP(pid,flag):  
  pid  -  (integer) process id of callee 
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE   
</tt></pre> 
  
This macro initializes the tracing area for a slave process and must be called  
once before any event is logged.  If the value of <tt>flag</tt> is set to  
<tt>ALOG_WRAP</tt>, then in the event of no more space for logging events the  
system will only report the latest n events.  If <tt>flag</tt> is set to  
<tt>ALOG_TRUNCATE</tt> the system will stop logging events as soon as there is  
no more memory for the events to be logged.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_MASTER(pid,flag): 
  pid  -  (integer) process id of the callee 
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE   
</tt></pre> 
  
This macro has the same effect over its parameters as  
<tt>ALOG_SETUP</tt> with the difference that this macro should be referenced by  
the master process only.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_DEFINE(event,strdef,format): 
  event  - (integer) id of event being defined 
  strdef - (string) description of 'event' 
  format - (string) control string in "printf" format  
</tt></pre> 
  
This macro puts an event definition code into the logfile.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_LOG(pid,event,intdata,strdata): 
  pid     - (integer) process id of callee 
  event   - (integer) event id to be logged 
  intdata - (integer) any integer data for this event 
  strdata - (string) any string data (can be the null string) 
</tt></pre> 
  
This macro provides the event logging service.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_OUTPUT 
  no parameters   
</tt></pre> 
  
This macro dumps the events logged into a log file with the name  
<em>alogfile.pxx</em> where <tt>xx</tt> is the logical PID of the callee process.  
The log file is created in the current directory unless specified otherwise  
through the macro ALOG_SETDIR.  All processes should execute this.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_SETDIR(dir) 
  dir - (string) directory where log file is created 
</tt></pre> 
  
This macro sets the output directory for the log file.  The default directory  
for the creation of the log file is the current directory of the process.  If  
used, then this macro MUST be invoked before <tt>ALOG_MASTER/ALOG_SETUP</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_STATUS(status): 
  status - (integer) either ALOG_ON or ALOG_OFF 
</tt></pre> 
  
<P>
This macro controls the logging status of <tt>ALOG</tt> as follows.  Setting  
<tt>status</tt> to <tt>ALOG_ON</tt> enables logging until it is turned off.  
Setting <tt>status</tt> to <tt>ALOG_OFF</tt> disables logging until it is turned  
on again.  Logging is enabled at the outset by default.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_ENABLE 
  no parameters 
</tt></pre> 
  
<P>
This macro enables event logging; same as calling <tt>ALOG_STATUS(ALOG_ON)</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
ALOG_DISABLE 
  no parameters 
</tt></pre> 
  
This macro disables event logging; same as calling  
<tt>ALOG_STATUS(ALOG_OFF)</tt>.  
<P>
The sample program <em>gridlog.shmem.c</em> in the <em>monitors</em> subdirectory  
contains an example of a program instrumented with ALOG statements.  The macro  
definitions for ALOG are included when you include <tt>#include "p4.h"</tt> in  
your program.  If the line <tt>#define ALOG_TRACE</tt> is not included before  
the <tt>#include "p4.h"</tt>, these macros will generate no code.  Thus it is  
easy to effectively de-instrument the code by recompiling, and there is no  
need to protect each ALOG statement with an <tt>#ifdef</tt>.  
 <P>
  
  
When an ALOG-instrumented program is run, it will produce one logfile for each  
process.  The files will be named <em>alogfile.p0</em>, <em>alogfile.p1</em>,  
....  These files need to be merged into a single file with the events  
sored by timestamp.  This is accomplished with the program <em>mergelogs</em>,  
found in the <em>bin</em> subdirectory.  To merge the logfiles, do   
<P>
<BR> 
<pre> 
<tt> 
mergelogs alogfile.p* &gt; myprog.log 
rm alogfile.p* 
</tt></pre> 
The resulting logfile can be examined by upshot or some other logfile  
examination facility.  See [(ref herrarte-lusk:upshot)] for details of the  
logfile format.  
<P>
  
  
On networks of workstations and some distributed memory machisnes, the  
microsecond timers on the various processors are synchronized.  To produce a  
usable merged logfile, the <em>adjlogs</em> program, also found in the  
<em>bin</em> directory, can be used to adjust the timestamps for offset and  
drift before they are merged.  For this to work, synchronization events must  
be placed in the logfiles by an <tt>ALOG_LOG</tt> statement.  The event type  
is then passed to <tt>adjlogs</tt>, which aligns the timestamps, based on the  
timestamps of the synchonization events.  The call to <tt>adjlogs</tt> looks  
like this, where <tt>&lt;n&gt;</tt> is the type of the synchronization event.  This  
program makes us of high-precision numeric libraries, and has been tested only  
on Sun's.  
<P>
<BR> 
<pre> 
<tt> 
adjlogs -e &lt;n&gt; 
</tt></pre> 
Both <tt>mergelogs</tt> and <tt>adjlogs</tt> are less portable than the other p4  
code;  you might want to run them on a workstation such as a Sun.  
<P>
 <P>
<HR><H2><A NAME="Node39">Creating Log Files in Fortran</a></H2>
<A HREF="p4.html#Node38"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node37"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node40"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<b>Next: </b><A HREF="p4.html#Node40"> Examining Log Files with Upshot</a>
<b>Previous: </b><A HREF="p4.html#Node38"> User-Specified Events</a>
<P>
  
  
<P>
Log files can also be created by Fortran programs.  The routines to do so are:  
<P>
  
<BR> 
<pre> 
<tt> 
alogfsetup(pid,flag):  
  pid  -  (integer) process id of callee 
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE   
</tt></pre> 
  
This function initializes the tracing area for a slave process and must be called  
once before any event is logged.  If the value of <tt>flag</tt> is set to  
<tt>ALOG_WRAP</tt>, then in the event of no more space for logging events the  
system will only report the latest n events.  If <tt>flag</tt> is set to  
<tt>ALOG_TRUNCATE</tt> the system will stop logging events as soon as there is  
no more memory for the events to be logged.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfmaster(pid,flag): 
  pid  -  (integer) process id of the callee 
  flag -  (integer) either 0 or 1  (see above) 
</tt></pre> 
  
This function has the same effect over its parameters as  
<tt>alogfsetup</tt> with the difference that this function should be referenced by  
the master process only.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfdefine(event,strdef,format): 
  event  - (integer) id of event being defined 
  strdef - (string) description of 'event' 
  format - (string) control string in "printf" format  
</tt></pre> 
  
This function puts an event definition code into the logfile.  
<P>
  
<BR> 
<pre> 
<tt> 
alogflog(pid,event,intdata,strdata): 
  pid     - (integer) process id of callee 
  event   - (integer) event id to be logged 
  intdata - (integer) any integer data for this event 
  strdata - (string) any string data (can be the null string) 
</tt></pre> 
  
This function provides the event logging service.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfoutput() 
</tt></pre> 
  
This function dumps the events logged into a log file with the name  
<em>alogfile.pxx</em> where <tt>xx</tt> is the logical PID of the callee process.  
The log file is created in the current directory unless specified otherwise  
through the function <tt>alogfsetdir</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfsetdir(dir) 
  dir - (string) directory where log file is created 
</tt></pre> 
  
This function sets the output directory for the log file.  The default directory  
for the creation of the log file is the current directory of the process.  If  
used, then this function MUST be invoked before <tt>alogfmaster/alogfsetup</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfstatus(status): 
  status - (integer) either ALOG_ON or ALOG_OFF 
</tt></pre> 
  
<P>
This function controls the logging status of <tt>ALOG</tt> as follows.  Setting  
<tt>status</tt> to <tt>ALOG_ON</tt> enables logging until it is turned off.  
Setting <tt>status</tt> to <tt>ALOG_OFF</tt> disables logging until it is turned  
on again.  Logging is enabled at the outset by default.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfenable() 
</tt></pre> 
  
<P>
This function enables event logging; same as calling  
<tt>alogfstatus(ALOG_ON)</tt>.  It must be called first, even before  
<tt>alogfmaster</tt> or <tt>alogfsetup</tt>.  
<P>
  
<BR> 
<pre> 
<tt> 
alogfdisable() 
</tt></pre> 
  
This function disables event logging; same as calling  
<tt>alogfstatus(ALOG_OFF)</tt>.  
<P>
The sample program <em>sr_log.f</em> in the <em>messages_f</em> subdirectory  
contains an example of a Fortran program instrumented with logging statements.  
<P>
 <P>
<HR><H2><A NAME="Node40">Examining Log Files with Upshot</a></H2>
<A HREF="p4.html#Node39"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node37"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node41"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<b>Next: </b><A HREF="p4.html#Node41"> Automatic Logging of p4 Events</a>
<b>Previous: </b><A HREF="p4.html#Node39"> Creating Log Files in Fortran</a>
<P>
  
  
<P>
<tt>Upshot</tt> is not part of the p4 distribution, but can be obtained from the  
same anonymous <tt>ftp</tt> location as p4.  Take the file <em>upshot.tar.Z</em>  
from the directory <em>pub/p4</em> on <tt>info.mcs.anl.gov</tt>.  The distribution  
contains all necessary documentation on how to install and run <tt>upshot</tt>.  
It is an X-window program that runs on most workstations.  There is no need  
for a parallel macchine to be involved, once the log files have been obtained.  
<P>
<tt>Upshot</tt> produces the most interesting displays when certain events  
(not necessarily all) are defined to be the entry and exit events for certain  
<em> states</em> and then colors are associated with the states.  This association  
is reflected in a <em> statefile</em> with a format like the following:  
<P>
<BR> 
<pre> 
<tt> 
1 1 2 red   asking 
2 3 4 blue  working 
3 5 6 green updating 
</tt></pre> 
This statefile describes three states.  State 1 is defined to be between  
events 1 and 2.  <tt>Upshot</tt> will color it red and label it ``asking''.  
<P>
 <P>
<HR><H2><A NAME="Node41">Automatic Logging of p4 Events</a></H2>
<A HREF="p4.html#Node40"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node37"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node42"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node37"> Creating Logfiles for Upshot</a>
<b>Next: </b><A HREF="p4.html#Node42"> Running p4 on Specific Machines</a>
<b>Previous: </b><A HREF="p4.html#Node40"> Examining Log Files with Upshot</a>
<P>
  
<P>
We have found that the most useful events to log and study are those  
identified by the user and specified in his program.  That way he can control  
the number of events to be logged and the grain size of the states that are  
represented.    
<P>
In some cases, however, one wants to study the details of the internal  
operation of a p4 application, or get some idea of the behavior on one's  
program without going to the trouble of instrumenting it himself.  To this  
end, p4 itself is instrumented with ALOG statements, although by default they  
are inactive.  To get automatic logging of p4 events (including sending and  
receiving of each message) one needs first to link to a version of the p4  
library that has been compiled with the line <tt>#define ALOG_TRACE</tt>  
uncommented out in the <em>OPTIONS</em> file, and secondly, to run with  
<tt>-p4log</tt> on the command line.  
<P>
Some important things to know about using the internal logging features of p4  
are:  
<P>
<ol> 
 
<BR> 
1. By default, logging is turned off at compile time in the OPTIONS file.  
 
<BR> 
2. If you link to a version of p4 that was compiled with logging turned  
  on in the OPTIONS file, then if you either use the -p4log option or do  
  ALOG_ENABLE in the program, you will get p4 internal log stuff.  Of  
  course, if you use ALOG_ENABLE and do some of your own logging, then it  
  will be mixed up with p4's.  The assumption is that you would probably  
  only link to a version of p4 that had internal logging turned on if you  
  wanted to debug p4 internals.  
 
<BR> 
3. If you link to a version of p4 that was compiled with logging turned off  
  in the OPTIONS file, then using the -p4log option will have no effect; also,  
  using ALOG_ENABLE will not cause p4 internals to log anything.  BUT, you can  
  do a "#define ALOG_TRACE" at the top of your program and do ALOG_ENABLE,  
  ALOG_LOGs, etc. and all of your own stuff will be logged.  NOTE that you must  
  do the #define above your #include "p4.h" because p4.h includes the alog.h  
  header file for you.  
 
<BR> 
4. It is suggested that at least in the case of internal logging, processes  
  should be created using <tt>p4_create_procgroup</tt> rather than  
  <tt>p4_create</tt>.  
</ol> 
<BR> 
 <P>
<HR><H1><A NAME="Node42">Running p4 on Specific Machines</a></H1>
<A HREF="p4.html#Node41"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node43"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node43"> Invoking a p4 Program</a>
<b>Previous: </b><A HREF="p4.html#Node41"> Automatic Logging of p4 Events</a>
<P>
 <menu> 
</menu> 
<P>
<HR><H2><A NAME="Node43">Invoking a p4 Program</a></H2>
<A HREF="p4.html#Node42"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node42"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node44"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node42"> Running p4 on Specific Machines</a>
<b>Next: </b><A HREF="p4.html#Node44"> Machine-Specific Notes</a>
<b>Previous: </b><A HREF="p4.html#Node42"> Running p4 on Specific Machines</a>
<P>
<dl> 
 
<dt> 
<b>Workstation Networks</b><dd> 
On networks of uniprocessors consisting of Suns,  
  HP machines, RS/6000's, CRAY's, SGI's, etc., just set up the appropriate  
  procgroup file and execute the master process.  Execution of the  
  <tt>p4_create_procgroup</tt> will start up the other processes, either via  
  remote shell or the server.  
 
<dt> 
<b>Shared-memory multiprocessors</b><dd> 
On machines such as the Sequent  
  Symmetry, Encore, KSR, IBM 3090, or Alliant, just execute the master program.  
 
<dt> 
<b>BBN Butterfly</b><dd> 
On the Butterfly TC-2000, one should invoke a program  
  with the ``cluster'' command:  <tt>cluster 10 systest -pg myprocgroup</tt>,  
  where <em>myprocgroup</em> describes 9 slave processes, or else the main  
  program will <tt>p4_create</tt> 9 processes.  
 
<dt> 
<b>IPSC860</b><dd> 
See the script <em>runipsc</em> in the <em>messages</em> directory.   
 
<dt> 
<b>DELTA</b><dd> 
See the script <em>rundelta</em> in the <em>messages</em> directory.   
 
<dt> 
<b>Paragon</b><dd> 
To run on the Paragon at Caltech, execute the program with  
  command-line arguments as follows:  
  <BR> 
<pre> 
<tt> 
    &lt;progname&gt;  -pn .compute -sz &lt;nprocs&gt; 
  </tt></pre> 
where <tt> nprocs</tt> is the total number of processes.  On some Paragons,  
 one must first create a partition with  
  the <tt>mkpart</tt> command (<tt>mkpart -sz &lt;size&gt; &lt;partname&gt;</tt>),  
  specifying the size and name of the partition.  At some installations, these  
  partitions are specicified ahead of time.  (The <tt>lspart</tt> command says  
  which partitions currently exist, and the <tt>rmpart</tt> command is used to  
  remove a user-allocated partition.  Once you have a partition, start your  
  program with:  
<BR> 
<pre> 
<tt> 
  myprog -pn &lt;partition name&gt;   
</tt></pre> 
The procgroup file should contain one line:  
<BR> 
<pre> 
<tt> 
  &lt;machinename&gt; &lt;nprocs-1&gt; &lt;pathname&gt;     
</tt></pre> 
 
<dt> 
<b>CM-5</b><dd> 
You are logged in to a particular front-end, which determines how  
  many nodes you have available.  Just run the program.  The procgroup file  
  should specify (as <tt>local</tt>) some number of slaves less than the number  
  of nodes available.  Also include the program pathname on the <tt>local</tt>  
  line in the procgroup file.  You don't have to use all the nodes.  
 
<dt> 
<b>nCube</b><dd> 
Say <tt>xnc -dN progname</tt> where <tt>N</tt> is the <em>  
  dimension</em> of the subcube to be allocated (i.e., the number of nodes  
  allocated will be 2 to the power N).  The procgroup file should look like  
  the one for the CM-5.  Try <tt>nman</tt> to access the man pages.  
 
<dt> 
<b>SP-1</b><dd> 
The IBM SP-1 has several modes.  To run (at least on the Argonne  
  system) with the Socket interface to the Ethernet, use <tt>spnode</tt>s in  
  the procgroup file, including a  
<BR> 
<pre> 
<tt> 
  spnode1 0 &lt;file&gt; 
</tt></pre> 
for the master.  To use the socket interface to the switch on the SP-1, use  
  <tt>swnode</tt>s for the nodes, including <tt>swnode1</tt> for the master.  
 
<dt> 
<b>SP1_EUI</b><dd> 
To use the IBM EUI interface to the switch  
  (<tt>P4ARCH=SP1_EUI</tt>), log into a node where EUI is running and do:  
<BR> 
<pre> 
<tt> 
  setenv MP_PROCS N  (where N is the number of processes you want) 
<P>
myprog 
</tt></pre> 
or  
<BR> 
<pre> 
<tt> 
  myprog -procs N 
</tt></pre> 
The procgroup file  should look like   
<BR> 
<pre> 
<tt> 
  local 15 &lt;progname&gt; 
</tt></pre> 
to run with 16 processes (15 slaves).  The program name in the procgroup file  
should be the full path name of the executable file.  Such a program may be  
be interactive, but there currently are problems flushing lines to the  
terminal that do not end in a newline character (typically, interactive  
prompts).   
 
<dt> 
<b>SP1_EUIH</b><dd> 
To use the experimental high-speed interface, log into a node  
  where EUIH is running and do:  
<BR> 
<pre> 
<tt> 
<P>
/usr/lpp/euih/eui/cotb0 -b &lt;progname&gt; &lt;numprocs&gt; &lt;user args&gt; 
<P>
</tt></pre> 
The procgroup file should look like   
<BR> 
<pre> 
<tt> 
  local 15 &lt;progname&gt; 
</tt></pre> 
to run with 16 processes (15 slaves).  The program name in the procgroup file  
should be the full path name of the executable file.  Such a program should  
not be interactive.  
 
<dt> 
<b>MEIKO_CS1</b><dd> 
Find an appropriately sized partition using  
<BR> 
<pre> 
<tt> 
  rinfo -a 
</tt></pre> 
and then start the job with  
<BR> 
<pre> 
<tt> 
  prun -n &lt;nprocs&gt; -lsv [-p &lt;partition name&gt;] &lt;progname&gt; 
</tt></pre> 
The <tt>-lsv</tt> option causes stdout to be routed to files.  
</dl> 
<BR> 
 <P>
<HR><H2><A NAME="Node44">Machine-Specific Notes</a></H2>
<A HREF="p4.html#Node43"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node42"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node45"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node42"> Running p4 on Specific Machines</a>
<b>Next: </b><A HREF="p4.html#Node45"> Some Common Problems and their Solutions</a>
<b>Previous: </b><A HREF="p4.html#Node43"> Invoking a p4 Program</a>
<P>
<BR> 
<pre> 
<tt> 
SUN 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
<P>
SUN_SOLARIS 
    (1)  P4 is made with shared memory by default, and instead of SysV shared 
         memory, uses the more efficient mmap. 
<P>
HP 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
    (2)  Fortran not tested (not avail on our test machine). 
<P>
DEC5000 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
<P>
ALPHA 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
<P>
RS6000 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
    (2)  It is important to use the option -lbsd on the link step to 
         get sockets to support the NONBLOCKING option. 
<P>
IBM3090 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
    (2)  Fortran not supported due to absence of iargc/getarg. 
    (3)  There are multiply defined macros in include/rpc/rpc.h.  IBM 
         is fixing this in a later OS release.  Meanwhile make your own 
         copy and the fix the problem yourself. 
    <P>
TITAN 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
    (2)  Fortran not supported due to problems with getting args. 
<P>
SGI 
    (1)  P4 can be installed on this machine with or without SYSV IPC. 
<P>
NEXT 
    (1)  Fortran not supported due to absence of iargc/getarg. 
<P>
FX2800/FX2800_SWITCH 
    (1)  Alliant's switch code not yet ensuring messages  
         remain ordered.  p4 currently discovers the switch port for 
         the machine it is running on by invoking the internal 
         procedure getswport.  This procedure must be customized to 
         the installation.  Alliant's switch is currently unsupported. 
      <P>
FX8 
    (1)  You might need to add MFLAGS = -i to the Makefile 
<P>
KSR 
    (1)  The latest version of the OS produces a link-time error for 
         Fortran programs. 
    (2)  Use of sockets fails because of a bug in socketpair. 
<P>
IPSC860 
    (1)  the script ``runcube'' (in the messages directory) may  
         be useful 
  <P>
DELTA 
    (1)  the script ``rundelta'' (in the messages directory) may  
         be useful 
<P>
BALANCE 
    (1)  Fortran not supported. 
<P>
SYMMETRY/SYMMETRY_PTX 
    (1)  -Z compiler option may be changed to control the 
            shmalloc/malloc split.  This is often needed when 
            creating logfiles on a symmetry. 
    (2)  shared memory message passing not supported in Fortran 
<P>
TC_2000/TC_2000_TCMP 
    (1)  TCMP port not yet complete. 
    (2)  For shared-memory execution, one must use </tt><tt>cluster ...</tt> to 
         obtain a private cluster for execution 
NCUBE 
    (1)  Messages are limited to 32K in length. 
<P>
CM5  
    (1)  Logfiles are not supported. 
<P>
SP1 
    (1)  Using ``spnoden'' for node names causes p4 to use the TCP 
         interface to the Ethernet. 
    (2)  Using ``swnoden'' for node names causes p4 to use the TCP  
         interface to the switch.  In this case, replace the line 
         ``local 0'' with ``swnode1 0'' in the procgroup file. 
    (3)  It is important to use the option -lbsd on the link step to 
         get sockets to support the NONBLOCKING option when using the  
         TCP interface to either the switch or the Ethernet. 
    (4)  EUIH programs may not be able to read from the keyboard. 
</tt></pre> 
 <P>
<HR><H1><A NAME="Node45">Some Common Problems and their Solutions</a></H1>
<A HREF="p4.html#Node44"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node46"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node46"> Concept Index</a>
<b>Previous: </b><A HREF="p4.html#Node44"> Machine-Specific Notes</a>
<P>
  
  
<P>
Our attempt with this manual has been to prevent you from having difficulties.  
Experience shows that certain common problems recur, however.  In this  
section we hope to address some of these problems.  
<P>
<dl> 
 
<dt> 
<b>``Permission Denied.''</b><dd> 
p4 slave processes are started by forks (for  
  slaves in the same shared-memory cluster), by the server, or by the remote  
  shell command.  If the server is running on the target machine then that  
  must be configured to allow remote processes to be started.  To test whether  
  this is your problem, try  
<BR> 
<pre> 
<tt> 
    rsh target.machine date 
</tt></pre> 
If you still get the ``Permission denied.'' message, then the problem has  
  nothing to do with p4.  See <tt>hosts.equiv</tt> or <tt>.rhosts</tt> in the  
  system man pages.  
 
<dt> 
<b>``More processes than message queues''</b><dd> 
Under the default configuration  
  of p4, uniprocessors, such as most workstations, cannot have multiple  
  processes sharing memory.  Thus your procgroup file for a workstation network  
  should always look like:  
<BR> 
<pre> 
<tt> 
    local 0 
    machine1 1 pathname 
    machine2 1 pathname 
    machine3 1 pathname 
       . 
       . 
</tt></pre> 
The ``local'' means ``only the master on the startup machine; no local  
  slaves sharing memory''.  
<P>
  
  It is possible, at some cost in message-passing efficiency, to have a  
  cluster of processes sharing memory on a workstation, but in this case p4  
  must have been installed with the <tt>SYSV_IPC</tt> option set in the  
  <em>OPTIONS</em> file.  The cost is that a process waiting for a message must  
  spin between checking for a message arriving on a socket and a message  
  arriving through shared memory.   
<P>
 
<dt> 
<b>``cannot find procgroup file''</b><dd> 
On the SP-1, Fortran EUIH programs that  
  have been linked with the <tt>-e main</tt> option cannot find their  
  command-line arguments, which are needed whether the procgroup file is named  
  implicitly or explicitly.  The solution is to remove <tt>-e main</tt> from the  
  link line in the makefile.  
<P>
 
<dt> 
<b>``gethostbyname failed 100 times''</b><dd> 
Check for an invalid machine name  
  in the procgroup file.  If all machine names being used are correct,  
  <tt>p4dmn</tt> command-line option might be helpful.  For example, if you are  
  running the master program on a machine named ``donner'', then it will  
  broadcast that name to other processes, but they may only be able to look  
  ``donner'' up in a file that refers to it as ``donner.mcs.anl.gov'', so  
  the <tt>-p4dmn</tt> option is used to supply the ``mcs.anl.gov'' part.  
  <P>
 
<dt> 
<b>``pgm_path_name: Command not found''</b><dd> 
P4 tried to start the program  
  with the given name on a remote machine and the program did not exist.  
  Verify the full path name of the program.  
 
<dt> 
<b>program hangs</b><dd> 
You may have failed to initialize the <tt>type</tt> and  
  <tt>from</tt> fields before a <tt>p4_recv</tt>.  You might have used  
  <tt>p4_sendr</tt> between two processes at the same time, which will deadlock  
  if you think about it, or even if you don't.  Use <tt>p4_send</tt> instead.  
 
<dt> 
<b>program hangs or has bad data in received message</b><dd> 
You might have  
  failed to set the pointer to the incoming buffer to NULL, or to have  
  specifically allocated a buffer with <tt>p4_msg_alloc</tt>, before a  
  <tt>p4_recv</tt>.  
 
<dt> 
<b>program fails to terminate</b><dd> 
Some Sequents and Suns have been found to be  
  running an old version of <tt>rsh</tt>, which leaves <tt>rsh</tt> processes  
  around, causing the master process not to terminate.  Be sure that you have  
  applied patch  100468-03 to your <tt>rsh</tt>, which should make it 7374 bytes  
  long.   
 
<dt> 
<b>program ignores command-line arguments</b><dd> 
You might have passed  
  <tt>argc</tt> instead of <tt>&amp;argc</tt> to <tt>p4_initenv</tt>.  
 
<dt> 
<b>program runs out of memory</b><dd> 
You may need to call <tt>p4_msg_free</tt>  
  after each <tt>p4_recv</tt>, or reuse buffers by pre-allocating them.  
<P>
</dl> 
<BR> 
  
<P>
 <P>
<HR><H1><A NAME="Node46">Concept Index</a></H1>
<A HREF="p4.html#Node45"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><A HREF="p4.html#Node47"><IMG SRC="next.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Next: </b><A HREF="p4.html#Node47"> Function Index</a>
<b>Previous: </b><A HREF="p4.html#Node45"> Some Common Problems and their Solutions</a>
<P>
</menu> 
<li><a href="p4.html#Node34">Fortran interface</a>
<li><a href="p4.html#Node45">IPC</a>
<li><a href="p4.html#Node2">OPTIONS</a>
<li><a href="p4.html#Node38">adjusting timestamps in log files</a>
<li><a href="p4.html#Node24">allocating buffers</a>
<li><a href="p4.html#Node30">askfor monitor</a>
<li><a href="p4.html#Node41">automatic logging</a>
<li><a href="p4.html#Node30">barrier</a>
<li><a href="p4.html#Node25">barrier</a>
<li><a href="p4.html#Node33">buffer pool management</a>
<li><a href="p4.html#Node31">clocks</a>
<li><a href="p4.html#Node22">cluster management</a>
<li><a href="p4.html#Node16">command-line arguments</a>
<li><a href="p4.html#Node28">data types for monitors</a>
<li><a href="p4.html#Node15">deallocating buffers</a>
<li><a href="p4.html#Node24">deallocating buffers</a>
<li><a href="p4.html#Node32">debugging</a>
<li><a href="p4.html#Node2">directory structure</a>
<li><a href="p4.html#Node5">documentation</a>
<li><a href="p4.html#Node6">examples</a>
<li><a href="p4.html#Node35">faster startup</a>
<li><a href="p4.html#Node7">getting started</a>
<li><a href="p4.html#Node25">global operations</a>
<li><a href="p4.html#Node3">installation</a>
<li><a href="p4.html#Node32">interrupts</a>
<li><a href="p4.html#Node30">lock</a>
<li><a href="p4.html#Node39">logfiles in Fortran</a>
<li><a href="p4.html#Node37">logging</a>
<li><a href="p4.html#Node4">machines</a>
<li><a href="p4.html#Node5">man pages</a>
<li><a href="p4.html#Node38">merging log files</a>
<li><a href="p4.html#Node23">message-passing functions</a>
<li><a href="p4.html#Node28">monitor data types</a>
<li><a href="p4.html#Node29">monitor primitives</a>
<li><a href="p4.html#Node30">monitors</a>
<li><a href="p4.html#Node5">online help</a>
<li><a href="p4.html#Node45">permission denied</a>
<li><a href="p4.html#Node35">permissions</a>
<li><a href="p4.html#Node45">problems</a>
<li><a href="p4.html#Node21">process management</a>
<li><a href="p4.html#Node11">procgroup files</a>
<li><a href="p4.html#Node24">receiving messages</a>
<li><a href="p4.html#Node19">return codes</a>
<li><a href="p4.html#Node35">rhosts</a>
<li><a href="p4.html#Node32">runaway processes</a>
<li><a href="p4.html#Node24">sending messages</a>
<li><a href="p4.html#Node35">servers</a>
<li><a href="p4.html#Node36">servers</a>
<li><a href="p4.html#Node28">shared memory data types</a>
<li><a href="p4.html#Node26">shared memory example</a>
<li><a href="p4.html#Node26">shared memory functions</a>
<li><a href="p4.html#Node16">starting processes by hand</a>
<li><a href="p4.html#Node40">statefile</a>
<li><a href="p4.html#Node4">testing</a>
<li><a href="p4.html#Node37">timestamps</a>
<li><a href="p4.html#Node31">timing</a>
<li><a href="p4.html#Node37">tracefiles</a>
<li><a href="p4.html#Node30">unlock</a>
<li><a href="p4.html#Node40">upshot</a>
<li><a href="p4.html#Node37">upshot</a>
<li><a href="p4.html#Node39">upshot</a>
<li><a href="p4.html#Node38">user events</a>
<li><a href="p4.html#Node36">utilities</a>
</menu> 
  
<P>
 <P>
<HR><H1><A NAME="Node47">Function Index</a></H1>
<A HREF="p4.html#Node46"><IMG SRC="previous.xbm"></A><A HREF="p4.html#Node0"><IMG SRC="up.xbm"></A><BR>
<b>Up: </b><A HREF="p4.html#Node0">Contents</a>
<b>Previous: </b><A HREF="p4.html#Node46"> Concept Index</a>
<P>
</menu> 
<li><a href="p4.html#Node38">ALOG_DEFINE</a>
<li><a href="p4.html#Node38">ALOG_DISABLE</a>
<li><a href="p4.html#Node38">ALOG_ENABLE</a>
<li><a href="p4.html#Node38">ALOG_LOG</a>
<li><a href="p4.html#Node38">ALOG_MASTER</a>
<li><a href="p4.html#Node38">ALOG_OUTPUT</a>
<li><a href="p4.html#Node38">ALOG_SETDIR</a>
<li><a href="p4.html#Node38">ALOG_SETUP</a>
<li><a href="p4.html#Node38">ALOG_STATUS</a>
<li><a href="p4.html#Node38">adjlogs</a>
<li><a href="p4.html#Node39">alogfdefine</a>
<li><a href="p4.html#Node39">alogfdisable</a>
<li><a href="p4.html#Node39">alogfenable</a>
<li><a href="p4.html#Node39">alogflog</a>
<li><a href="p4.html#Node39">alogfmaster</a>
<li><a href="p4.html#Node39">alogfoutput</a>
<li><a href="p4.html#Node39">alogfsetdir</a>
<li><a href="p4.html#Node39">alogfsetup</a>
<li><a href="p4.html#Node39">alogfstatus</a>
<li><a href="p4.html#Node38">mergelogs</a>
<li><a href="p4.html#Node21">p4_alloc_procgroup</a>
<li><a href="p4.html#Node22">p4_am_i_cluster_master</a>
<li><a href="p4.html#Node30">p4_askfor</a>
<li><a href="p4.html#Node30">p4_askfor_init</a>
<li><a href="p4.html#Node30">p4_barrier</a>
<li><a href="p4.html#Node30">p4_barrier_init</a>
<li><a href="p4.html#Node25">p4_broadcast</a>
<li><a href="p4.html#Node25">p4_broadcastx</a>
<li><a href="p4.html#Node31">p4_clock</a>
<li><a href="p4.html#Node22">p4_cluster_shmem_sync</a>
<li><a href="p4.html#Node21">p4_create</a>
<li><a href="p4.html#Node21">p4_create_procgroup</a>
<li><a href="p4.html#Node32">p4_dprintf</a>
<li><a href="p4.html#Node32">p4_dprintfl</a>
<li><a href="p4.html#Node32">p4_error</a>
<li><a href="p4.html#Node27">p4_free</a>
<li><a href="p4.html#Node22">p4_get_cluster_ids</a>
<li><a href="p4.html#Node22">p4_get_cluster_masters</a>
<li><a href="p4.html#Node32">p4_get_dbg_level</a>
<li><a href="p4.html#Node22">p4_get_my_cluster_id</a>
<li><a href="p4.html#Node21">p4_get_my_id</a>
<li><a href="p4.html#Node30">p4_getsub</a>
<li><a href="p4.html#Node30">p4_getsub_init</a>
<li><a href="p4.html#Node30">p4_getsubs</a>
<li><a href="p4.html#Node25">p4_global_barrier</a>
<li><a href="p4.html#Node25">p4_global_op</a>
<li><a href="p4.html#Node21">p4_initenv</a>
<li><a href="p4.html#Node30">p4_lock</a>
<li><a href="p4.html#Node30">p4_lock_init</a>
<li><a href="p4.html#Node27">p4_malloc</a>
<li><a href="p4.html#Node29">p4_mcontinue</a>
<li><a href="p4.html#Node29">p4_mdelay</a>
<li><a href="p4.html#Node29">p4_menter</a>
<li><a href="p4.html#Node24">p4_messages_available</a>
<li><a href="p4.html#Node29">p4_mexit</a>
<li><a href="p4.html#Node29">p4_moninit</a>
<li><a href="p4.html#Node24">p4_msg_alloc</a>
<li><a href="p4.html#Node24">p4_msg_free</a>
<li><a href="p4.html#Node22">p4_num_cluster_ids</a>
<li><a href="p4.html#Node21">p4_num_total_ids</a>
<li><a href="p4.html#Node21">p4_num_total_slaves</a>
<li><a href="p4.html#Node33">p4_print_avail_buffs</a>
<li><a href="p4.html#Node30">p4_probend</a>
<li><a href="p4.html#Node30">p4_progend</a>
<li><a href="p4.html#Node24">p4_recv</a>
<li><a href="p4.html#Node24">p4_send</a>
<li><a href="p4.html#Node24">p4_sendb</a>
<li><a href="p4.html#Node24">p4_sendbr</a>
<li><a href="p4.html#Node24">p4_sendbrx</a>
<li><a href="p4.html#Node24">p4_sendbx</a>
<li><a href="p4.html#Node24">p4_sendr</a>
<li><a href="p4.html#Node24">p4_sendrx</a>
<li><a href="p4.html#Node24">p4_sendx</a>
<li><a href="p4.html#Node33">p4_set_avail_buff</a>
<li><a href="p4.html#Node32">p4_set_dbg_level</a>
<li><a href="p4.html#Node27">p4_shfree</a>
<li><a href="p4.html#Node27">p4_shmalloc</a>
<li><a href="p4.html#Node32">p4_soft_errors</a>
<li><a href="p4.html#Node21">p4_startup</a>
<li><a href="p4.html#Node30">p4_unlock</a>
<li><a href="p4.html#Node30">p4_update</a>
<li><a href="p4.html#Node31">p4_usrollover</a>
<li><a href="p4.html#Node31">p4_ustimer</a>
<li><a href="p4.html#Node33">p4_version</a>
<li><a href="p4.html#Node21">p4_wait_for_end</a>
<li><a href="p4.html#Node34">p4avlbufs</a>
<li><a href="p4.html#Node34">p4brdcst</a>
<li><a href="p4.html#Node34">p4brdcstx</a>
<li><a href="p4.html#Node34">p4cleanup</a>
<li><a href="p4.html#Node34">p4clock</a>
<li><a href="p4.html#Node34">p4crpg</a>
<li><a href="p4.html#Node34">p4error</a>
<li><a href="p4.html#Node34">p4flush</a>
<li><a href="p4.html#Node34">p4getclids</a>
<li><a href="p4.html#Node34">p4getclmasts</a>
<li><a href="p4.html#Node34">p4globarr</a>
<li><a href="p4.html#Node34">p4globop</a>
<li><a href="p4.html#Node34">p4init</a>
<li><a href="p4.html#Node34">p4myclid</a>
<li><a href="p4.html#Node34">p4myid</a>
<li><a href="p4.html#Node34">p4nclids</a>
<li><a href="p4.html#Node34">p4nslaves</a>
<li><a href="p4.html#Node34">p4ntotids</a>
<li><a href="p4.html#Node34">p4probe</a>
<li><a href="p4.html#Node34">p4recv</a>
<li><a href="p4.html#Node34">p4send</a>
<li><a href="p4.html#Node34">p4sendr</a>
<li><a href="p4.html#Node34">p4sendrx</a>
<li><a href="p4.html#Node34">p4sendx</a>
<li><a href="p4.html#Node34">p4setavlbuf</a>
<li><a href="p4.html#Node34">p4softerrs</a>
<li><a href="p4.html#Node34">p4ustimer</a>
<li><a href="p4.html#Node34">p4version</a>
</menu> 
  
<P>
  
<P>
This copy was produced on Wed Apr  6 14:29:28 1994.  
<P>
<P>
