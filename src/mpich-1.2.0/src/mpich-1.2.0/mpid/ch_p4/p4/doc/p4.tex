%\documentstyle[11pt,titlepage,latexinfo,twoside]{article}
\documentstyle[11pt,titlepage,latexinfo-1.2]{article}
\textwidth=6.0in 
\textheight=9.0in
\hoffset=-0.5in	
\voffset=-1.0in
\parskip=.1in
\pagestyle{empty}

\begin{document}
\bibliographystyle{plain}

\newindex{cp}
\newindex{fn}

\begin{iftex}

{\advance\leftskip 4.0in
\noindent
Distribution Category: \\
Mathematics and \\ 
\null\nobreak\hspace{.25in} Computer Science (UC-405)
\par
}

\begin{center}

\vspace{.2in}
{\large
ARGONNE NATIONAL LABORATORY\\
}
9700 South Cass Avenue \\
Argonne, IL 60439-4801
\end{center}

\vspace{.06in}
\begin{center}
{\large\bf
-----------------\\
ANL-92/17 \\
-----------------\\
}
\end{center}
\vskip .75 in
\begin{center}
{\Large\bf
User's Guide to the p4 Parallel Programming System}
\end{center}
\vskip .1 in
\begin{center}
by
\end{center}
\vskip .1in
\begin{center}
{\large \em Ralph Butler* and Ewing Lusk}
\vskip .5 in
Mathematics and Computer Science Division

\vskip 1.5 in
October 1992 \\
(Revised, April 1994)
\end{center}
\vfill
\begin{quote}
{\small This work was supported in part by
the Applied Mathematical Sciences subprogram of the Office of Energy
Research under
Contract W-31-109-Eng-38.}

\smallskip

\noindent
*Also of The University of North Florida, Department of Computer Science, 
Jacksonville, Florida

\end{quote}

\clearpage

\end{iftex}

\pagestyle{headings}
\pagenumbering{roman}
\tableofcontents

\clearpage
\addcontentsline{toc}{section}{Abstract}
\vskip 3 in
\begin{abstract}
  This is both the reference manual and the User's Guide for the p4 parallel
  programming system.  It contains definitions of all functions for both C and
  Fortran, examples, a brief tutorial, and discussions of related systems.
\end{abstract}

\pagenumbering{arabic}
\clearpage

\setfilename{p4.info}

\node Top, Introduction, (dir), (dir)

\begin{ifinfo}
                                    
                   The p4 Parallel Programming System
                                    
                              Ralph Butler
                               Ewing Lusk


\begin{menu}
* Introduction::
* Structure of the Distribution Directory::
* Installing p4::
* Getting Started::
* Specifying Processes in the Procgroup File::
* Developing a Simple p4 Program::
* Command-Line Arguments::
* The p4 Function Library::
* p4 Functions for Managing Processes and Clusters::
* Functions for Message Passing::
* Functions for Shared Memory::
* Functions for Timing p4 Programs::
* Functions for Debugging p4 Programs::
* Miscellaneous Functions::
* Fortran Interface::
* Faster Startup with the Secure Server::
* Utilities for Managing a p4 Session::
* Creating Logfiles for Upshot::
* Running p4 on Specific Machines::
* Some Common Problems and their Solutions::
* Concept Index::
* Function Index::

 --- The Detailed Node Listing ---

Installing p4

* Installing the p4 System::
* Installing the Documentation::
* Examples included with the Distribution::

Getting Started

* A Message-Passing Example::
* Program Description::
* Analysis of the Program::

Developing a Simple p4 Program

* A Minimal Example::
* A Minimal Example in Fortran::
* A More Complicated Example::

The p4 Function Library

* Overview of the Library::
* Return Codes from p4 Functions::

p4 Functions for Managing Processes and Clusters

* Functions for Process Management::
* Functions for Cluster Management::

Functions for Message Passing

* Explicit Sending and Receiving of Messages::
* Global Operations::

Functions for Shared Memory

* Managing Shared and Local Memory::
* Shared Memory Data Types::
* Monitor-Building Primitives::
* Some Useful Monitors::

Creating Logfiles for Upshot

* User-Specified Events::
* Creating Log Files in Fortran::
* Examining Log Files with Upshot::
* Automatic Logging of p4 Events::

Running p4 on Specific Machines

* Invoking a p4 Program::
* Machine-Specific Notes::
\end{menu}

\end{ifinfo}


\node Introduction, Structure of the Distribution Directory, Top, Top
\section{Introduction}

P4 is a library of macros and subroutines developed at Argonne National
Laboratory for programming a variety of parallel machines.  A paper
describing its functions and use is \cite{butler-lusk:p4-paper}.  Its
predecessor was the m4-based ``Argonne macros'' system described in the
Holt, Rinehart, and Winston book {\em Portable Programs for Parallel
Processors}, by Lusk, Overbeek, et al., from which p4 takes its
name\cite{lusk-overbeek:p4-book}.  The current p4 system maintains the
same basic computational models described there (monitors for the
shared-memory model, message-passing for the distributed-memory model,
and support for combining the two models) while significantly increasing
ease and flexibility of use. \xref{Getting Started} for a simple example.

P4 is intended to be portable, simple to install and use, and efficient.  It
can be used to program networks of workstations, advanced parallel
supercomputers like the Intel Touchstone Delta and the Alliant Campus
HiPPI-based system, and single shared-memory multiprocessors.  It has
currently been installed on the following list of machines: Sequent Symmetry
(Dynix and PTX), Convex, Encore Multimax, Alliant FX/8, FX/800, and FX/2800,
Cray X/MP, Sun (SunOS and Solaris), NeXT, DEC, Silicon Graphics, HP, and IBM
RS6000 workstations, Stardent Titan, BBN GP-1000 and TC-2000, Kendall Square,
nCube, Intel IPSC/860, Intel Touchstone Delta, Intel Paragon, Alliant Campus,
Thinking Machines' CM-5, and the IBM SP-1 (TCP/Ethernet, TCP/switch, EUI, and
EUI-H).  It is not difficult to port to new systems.  Although p4 tries to be
completely portable, there are a small number of specific exceptions
(\xref{Machine-Specific Notes}) that may need to be taken into account on a
given machine.

You can obtain the complete distribution of p4 by anonymous ftp from
\code{info.mcs.anl.gov} in the directory \file{pub/p4}.  See the \code{README}
file there for recent news on what is available.  Take the file
\file{p4-1.4.tar.Z}.  The distribution contains all source code,
installation instructions, this reference manual, and a collection of examples
in both C and Fortran. \code{Alog} is included in the distribution with p4.
The file \file{upshot.tar.Z} contains display facilities that can be used with
p4 and other systems.

To ask questions about p4, report bugs, contribute examples, etc., you can
send mail to \code{p4@mcs.anl.gov}.

The current release is version 1.4.  You can check which version of the source
code you have by looking at the file \file{lib/p4_patchlevel.h} in the
distribution.  You can check which version of the object code you have linked
to by running any p4 program with the command-line option \code{-p4version}
(\xref{Command-Line Arguments}).

Salient features of p4 include: 
\begin{itemize}
\item support for both message-passing and explicit shared memory operations
\item \code{xdr} support for heterogeneous networks
\item World Wide Web version of the manual for on-line help
\item SYSV IPC support for shared-memory multiprocessing on workstations that
  support multiple processors, and simulating it on uniprocessors
\item instrumentation for automatic logging/tracing
\item automatic or user control of message-passing/buffer-management
\item error/interrupt handling
\item an optional p4 server for quick startup on remote machines
\end{itemize}

A useful companion system is the \code{alog/upshot} logging and X-based trace
examination facility.  (\xref{Creating Logfiles for Upshot}.)


\node Structure of the Distribution Directory, Installing p4, Introduction, Top
\section{Structure of the Distribution Directory}
\cindex{directory structure}

The p4 source code distribution contains the following files and
subdirectories:

\cindex{OPTIONS}
\begin{description}
\item[CHANGES] Changes new to this release of p4.
\item[Makefile] The makefile for making the p4 system, doing the installation,
  and making makefiles for user applications.
\item[OPTIONS] A file controlling various compile-time options, such as
  whether System V shared-memory operations are to be enabled, whether system
  debug message printing is to be enabled, and whether automatic
  instrumentation of internal p4 operations for the \code{upshot} logging and
  tracing program is to be done.  It also contains the full pathname of the
  listener to be used.
\item[README] General instructions, including how to build and install pr.
\item[alog] Source code for the ALOG tracing package.
\item[bin] Scripts for starting and killing servers, killing runaway p4
  processes, merging \code{upshot} logfiles, and other useful utilities.
\item[contrib] Examples contributed by p4 users.
\item[contrib_f] Fortran examples contributed by users.
\item[doc] The man page, together with this manual and supporting files,
  including a reference card for p4 routines.
\item[include] The include directory for making p4 applications.  Most of
  these are (hard) links into the \code{lib} directory.
\item[lib] The source code for the p4 system.
\item[lib_f] The Fortran interface for p4.  
\item[messages] A basic set of message-passing examples in C.
\item[messages_f] A basic set of message-passing examples in Fortran.
\item[misc] A few odds and ends of programs that fit no special category.
  Some of these have been found useful during debugging.
\item[monitors] A basic set of shared-memory examples in C.
\item[servers] The secure and insecure servers.
\item[usc] The portable microsecond clock routines.
\item[util] Assorted supporting files, particularly for making the p4
  distribution. 
\end{description}


\node Installing p4, Getting Started, Structure of the Distribution Directory, Top
\section{Installing p4}
\cindex{installation}

In this section we describe how to install the p4 library, either for
your own personal use or for the use of everyone at your site.  In the
first case you do not need any super-user privileges.  In the second
case, you may or may not, depending on how things are configured at
your site.  We also describe how to install and run the examples that
come with p4, the online help system (this manual as a World Wide Web document)
and how to build a working directory for your own programs yet share
the installed copy of p4 with other users.





\begin{menu}
* Installing the p4 System::
* Installing the Documentation::
* Examples included with the Distribution::
\end{menu}

\node Installing the p4 System, Installing the Documentation, Installing p4, Installing p4
\subsection{Installing the p4 System}

To build p4, position yourself in the top-level p4 directory (Here we refer to
this directory as \code{p4}, but you may have it as \code{p4-1.4} or something
similar) and type:
\begin{example}
make all P4ARCH=<machine>
\end{example}
\noindent
where <machine> is one of the machine names listed in
\file{p4/util/machines}, currently:
\cindex{machines}

\begin{ifinfo}
\begin{description}
\item[SUN] Sun-3, Sun386i, Sparc-1, Sparc-2, or Sparc-10 workstations, running
  SunOS

\item[SUN_SOLARIS] Sun workstations running Solaris

\item[HP] HP workstations

\item[DEC5000] Dec 5000 workstations

\item[ALPHA] Dec Alpha workstations

\item[NEXT] 68030- or 68040-based NeXT workstations

\item[RS6000] IBM RS 6000 series workstations

\item[LINUX]  IBM-compatible PC's running the LINUX operating system

\item[IBM3090] IBM 3090 running IBM's version of UNIX, AIX

\item[BALANCE] Sequent Balance shared-memory multiprocessor

\item[SYMMETRY] Sequent Symmetry shared-memory multiprocessor

\item[SYMMETRY_PTX] Sequent Symmetry shared-memory multiprocessor PTX OS

\item[MULTIMAX] Encore Multimax shared-memory multiprocessor

\item[GP_1000] BBN GP-1000

\item[TC_2000] BBN TC-2000

\item[TC_2000_TCMP] BBN TC-2000 with the TCMP message-passing library

\item[IPSC860] Intel IPSC/860 (nodes only)

\item[IPSC860_SOCKETS] Intel IPSC/860 with socket libraries on the nodes

\item[DELTA] Intel DELTA 

\item[PARAGON] Intel Paragon

\item[TITAN] Stardent Titan

\item[SGI] Silicon Graphics workstations

\item[CRAY] Cray X/MP

\item[FX8] Alliant FX/8

\item[FX2800] Alliant FX/2800 or FX/800

\item[FX2800_SWITCH] Alliant FX/2800 or FX/800, with CAMPUS HiPPI switch

\item[KSR] Kendall Square KSR-1

\item[CM-5] Thinking Machines' CM-5

\item[SP1] IBM SP-1 with TCP interface to either Ethernet or switch

\item[SP1_EUI] IBM SP-1 with IBM's EUI interface to the switch

\item[SP1_EUIH] IBM SP-1 with IBM's experimental EUI-H switch interface

\item[MEIKO_CS2] Meiko Computing Surface

\end{description}

\end{ifinfo}

\begin{iftex}
\begin{tex}
\begin{tabular}{l l}
{\tt SUN} & Sun-3, Sun386i, Sparc-1, Sparc-2, or Sparc-10 workstations \\
{\tt SUN\_SOLARIS} & Sun workstations running Solaris \\
{\tt HP} & HP workstations \\
{\tt DEC5000} &  DEC 5000 workstations \\
{\tt ALPHA} &  DEC Alpha workstations \\
{\tt NEXT} &  68030- or 68040-based NeXT workstations \\
{\tt RS6000} &  IBM RS 6000 series workstations \\
{\tt LINUX}  & IBM-compatible PC's running the LINUX operating system \\
{\tt IBM3090} &  IBM 3090 running IBM's version of UNIX, AIX \\
{\tt BALANCE} &  Sequent Symmetry shared-memory multiprocessor \\
{\tt SYMMETRY} &  Sequent Symmetry shared-memory multiprocessor \\
{\tt SYMMETRY\_PTX} &  Sequent Symmetry shared-memory multiprocessor PTX OS \\
{\tt MULTIMAX} &  Encore Multimax shared-memory multiprocessor \\
{\tt GP\_1000} &  BBN GP-1000 \\
{\tt TC\_2000} &  BBN TC-2000 \\
{\tt TC\_2000\_TCMP} &  BBN TC-2000 with the TCMP message-passing library \\
{\tt IPSC860} &  Intel IPSC/860 (nodes only) \\
{\tt DELTA} &  Intel DELTA  \\
{\tt PARAGON} & Intel Paragon \\
{\tt TITAN} &  Stardent Titan \\
{\tt SGI} &  Silicon Graphics workstations \\
{\tt CRAY} &  Cray X/MP or C-90 \\
{\tt FX8} &  Alliant FX/8 \\
{\tt FX2800} &  Alliant FX/2800 or FX/800 \\
{\tt FX2800\_SWITCH} &  Alliant FX/2800 or FX/800, with CAMPUS HiPPI switch \\
{\tt KSR} &  Kendall Square KSR-1 \\
{\tt CM5} &  Thinking Machines' CM-5 \\
{\tt SP1} & IBM SP-1 with TCP interface to either Ethernet or switch \\
{\tt SP1\_EUI} & IBM SP-1 with IBM's EUI interface to the switch \\
{\tt SP1\_EUIH} & IBM SP-1 with IBM's experimental EUI-H switch interface \\
{\tt NCUBE} & Ncube \\
{\tt MEIKO\_CS2}  & Meiko Computing Surface \\

\end{tabular}
\end{tex}
\end{iftex}

\noindent
For example:
\begin{example}
make all P4ARCH=SYMMETRY
\end{example}
\noindent
The \code{all} is optional, for example
\begin{example}
make P4ARCH=SYMMETRY
\end{example}
\noindent
This will create a machine-dependent \file{Makefile} in each subdirectory,
make the p4 library, and compile and link a subset of the examples.

To add a new machine type, or to change the characteristic parameters
associated with an existing one, you can edit the file 
\file{p4/util/defs.all}.

To save disk space, various intermediate object files can be removed with
\begin{example}
make clean
\end{example}
\noindent
The system can be restored to its original, machine-independent state with
\begin{example}
make realclean
\end{example}
\noindent
Note that this removes the machine-dependent Makefiles in each directory, so
the operation is not idempotent.

\noindent
It is also possible to install (or clean) only some of the directories:
\begin{example}
make all P4ARCH=SUN DIRS=messages
make clean DIRS='monitors messages'
\end{example}
\noindent
To install only the Makefiles in all subdirectories, use:
\begin{example}
make makefiles P4ARCH=<machine>
\end{example}
\noindent
To install the necessary library and include files in a
directory everything that is needed to compile and link p4 programs, 
do:

\begin{example}
make install INSTALLDIR=<dir>
\end{example}
\noindent
This will create a p4 directory in \code{<dir>}, build a
minimal set of directories, copy the relevant \file{.a} and \file{.h} files
into it, and test the installation by mking a small set of examples.

\cindex{testing}
\xref{Getting Started} for instructions on how to run some example
programs after you have installed p4.

\node Installing the Documentation, Examples included with the Distribution, Installing the p4 System, Installing p4
\subsection{Installing the Documentation}
\cindex{documentation}
\cindex{man pages}
\cindex{online help}

The directory \file{p4/doc} contains this manual as well as files that
require installation.  This manual was prepared with the
\code{latexinfo} package from GNU emacs.
The files in \file{p4/doc} are:

\begin{description}
\item[p4.tex] the latex source for this manual, which uses the latexinfo style

\item[latexinfo.sty, titlepage.sty] the style files needed to latex this manual

\item[p4.html] an html version of this manual, suitable for being installed
   in your World Wide Web pages.

\item[p4.txt] plain ascii text of the manual, in case nothing else works.

\item[p4refcard.ps] postscript version of a reference card

\item[p4.1] unix man page for the p4 library

\item[p4f.1] unix man page for the Fortran interface to p4

\item[fiber] status of the work on direct fiber channel

\end{description}

The Postscript version of this manual is available by anonymous \code{ftp}
from \code{info.mcs.anl.gov}, in the directory \file{pub/p4}.  The file to get
(in binary mode) is \file{p4-manual.ps.Z}.  There is also a paper there giving
an overview of p4, in \file{p4-paper.ps.Z}.  This manual is also available
through the World Wide Web at
\code{http://www.mcs.anl.gov/home/lusk/p4/p4-manual/p4.html}.


\node Examples included with the Distribution,  , Installing the Documentation, Installing p4
\subsection{Examples included with the Distribution}
\cindex{examples}

A good way to see how various p4 functions are used is to look at the example
programs included in the distribution.  The \file{p4/monitors} directory
contains shared-memory examples written in C that use monitors, including one
instrumented with ALOG.  The \file{p4/messages} subdirectory contains
message-passing examples written in C.  The programs in \file{p4/messages_f}
are Fortran message-passing examples, and the \file{p4/contrib} and
\file{p4/contrib_f} directories contain a number of miscellaneous examples
contributed by users.  In each directory there is a \file{README} that
describes the individual examples.


\node Getting Started, Specifying Processes in the Procgroup File, Installing p4, Top
\section{Getting Started}
\cindex{getting started}

The easiest way to get started with p4 is to play with some of the
sample programs provided with the system.




\begin{menu}
* A Message-Passing Example::
* Program Description::
* Analysis of the Program::
\end{menu}

\node A Message-Passing Example, Program Description, Getting Started, Getting Started
\subsection{A Message-Passing Example}

We will begin with a message-passing example in the sub-directory named
\file{p4/messages}.  The code for the program is in the files \file{sr_test.c}
and \file{sr_user.h}.


\node Program Description, Analysis of the Program, A Message-Passing Example, Getting Started
\subsection{Program Description}

As the name implies, this program is an example of p4's send/receive
functionality.  Briefly, it is a simple program that runs a master
process and some slave processes.  The master and the set of slaves
form a ring of processes in which the master reads a message from stdin
and sends a copy of the message to the first slave, which passes it on;
the last slave passes the message back to the master.  If the master
receives an undamaged copy of the message, it assumes that all went
well, and reads another message.  Note that the ring of processes is a
logical structure in which each process assumes that its
predecessor in the ring is the process with the next lower id, and
its successor is the process with the next higher id.  The master
has id 0 (zero) and has the process with the largest id as its
predecessor.



\node Analysis of the Program,  , Program Description, Getting Started
\subsection{Analysis of the Program}

The first executable p4 statement in a program should be:
\begin{example}
p4_initenv(&argc,argv); 
\end{example}
\noindent
This initializes the p4 system and allows p4 to extract any command
line arguments passed to it, e.g. debugging parameters.  

Similarly, the last executable p4 statement in a program should be:
\begin{example}
p4_wait_for_end(); 
\end{example}
\noindent
This waits for termination of p4 processes and performs some cleanup
operations.

The procedure \code{p4_get_my_id} returns the unique integer id assigned
to the calling process by p4.

The statement:
\begin{example}
p4_create_procgroup();
\end{example}
\noindent
reads a procgroup file that the user builds and creates the set of
slaves described in that file.  Obviously this statement must be
executed before any slaves can be assumed to exist.  This procedure
is the method you must use to create processes that do message-passing.

The procedure \code{p4_clock} returns an integer that represents
wall-clock time in milliseconds.  It is typically used to retrieve the
time before and after some work, the difference representing the time to
do that work.  Note that there is also a \code{p4_ustimer} that is useful on
those machines that support a microsecond timer.

The procedures \code{p4_send} and \code{p4_sendr} are two of several 
p4 procedures that are available for sending messages to other processes.
They take as arguments the message type, the id of the "to" process,
the address of the message, and the message length.

The procedure \code{p4_recv} receives a message from another process and
sets the values of all four parameters.  \code{P4_recv} will automatically
retrieve a buffer in which to place a received message, thus
\code{p4_msg_free} may be called to free that buffer when it is no longer
needed.

The procedure \code{p4_num_total_slaves} is one of several procedures that
the user can invoke to determine information about the current execution.

To run this program, you need to create a procgroup file that describes
where all slave processes are to be executed 
(\xref{Specifying Processes in the Procgroup File}).  We will assume that
you have an example procgroup file (named \file{sr_test.pg}) in the 
\file{p4/messages} directory, and can run \code{sr_test} by merely typing:
\begin{example}
sr_test
\end{example}
\noindent
If the procgroup file is elsewhere, then you must type:
\begin{example}
sr_test -pg  {\it pathname_of_procgroup_file}
\end{example}

\noindent
Another example that is made by default is the program \code{systest}.  It
tests a number of the message-passing features of p4.


\node Specifying Processes in the Procgroup File, Developing a Simple p4 Program, Getting Started, Top
\section{Specifying Processes in the Procgroup File}
\cindex{procgroup files}

The procgroup file is the only portion of the interface that is very likely to
change through multiple versions of p4.  As new architectures are supported,
it is hoped that we can merely alter the procgroup file format to reflect any
new features.  (Of course new procedure calls may also be required, but
existing procedure calls will remain unchanged when possible).  See
\xref{Running p4 on Specific Machines} for a discussion of machine
dependencies in starting p4 programs.

The current format of a procgroup file is as follows:
\begin{example}
local_machine  n [full_path_name] [loginname]
remote_machine n full_path_name [loginname]
  .
  .
  .
\end{example}
\noindent

In some situations, the program is started via some
special command executed from the host machine.  In such cases, the
procgroup file name can be specified to the special command line along
with the program name (see for example the \code{runcube} and \code{rundelta}
shell scripts in the \file{p4/messages} subdirectory).  In those cases 
where no special command is required, no special handling is required 
for the procgroup filename.

The first line of a procgroup file may be ``local n'' where n is the number
of slave processes that share memory with the master.  The full path
name on the ``local'' line is ignored on machines other than cube and mesh
machines, and the IBM SP-1.  The word ``local'' may be replaced by an alias
for the local machine if needed, to specify an alternative transport layer.
The subsequent lines contain either three or four
fields:
\begin{enumerate}
\item
the name of a remote machine on which slave processes are to be created.
\item
the number of slaves that are to be created on that machine, 
i.e. be in the same cluster (note that on machines that support it, 
the processes in a cluster will share memory)
\item
the full path name of the executable slave program
\item
optionally, the user login name on the remote machine, if different from 
that on the host machine.
\end{enumerate}

As an example, let's assume that you have a network of three Sun 
workstations named sun1, sun2, and sun3.  We will also assume that you 
are working on sun1 and plan to run a master process there.  
If you would like to run one process on each of the other Suns, then you 
might code a procgroup file that looks like:

\begin{example}
    # start one slave on each of sun2 and sun3
    local 0 
    sun2  1  /home/mylogin/p4pgms/sr_test
    sun3  1  /home/mylogin/p4pgms/sr_test
\end{example}

Lines beginning with \code{#} are comments.

It is also possible to have different executables on different machines.  This
is required, of course, when the machines don't share files or are of
different architectures.  An example of such a procgroup file would be:

\begin{example}
    local   0
    sun2    1  /home/user/p4pgms/sun/prog1
    sun3    1  /home/user/p4pgms/sun/prog2
    rs6000  1  /home/user/p4pgms/rs6000/prog1
\end{example}

On a shared memory machine such as a KSR, in which you want all the processes
to communicate through shared memory using monitors, the procgroup file can be
as simple as:

\begin{example}
    local 50
\end{example}

On the CM-5, your procgroup file would look like:

\begin{example}
    local 32 /home/joe/p4progs/cm5/multiply
\end{example}

Next, let's assume that you have a Sequent Symmetry (named \code{symm}) and an
Encore Multimax (named \code{mmax}).  We will also assume that you are working
on \code{symm}, and plan to run the master there.  If you would like to run
two processes on \code{symm} (in addition to the master) and two on
\code{mmax}, then you might code a procgroup file that looks like:

\begin{example}
    local 2 
    mmax  2  /mmaxfs/mylogin/p4pgms/sr_test
\end{example}

P4 also permits you to treat the symmetry as a remote machine even when 
you are running the master there.  Thus, you might code a procgroup file 
as follows:

\begin{example}
    local 2 
    symm  2  /symmfs/mylogin/p4pgms/sr_test
    mmax  2  /mmaxfs/mylogin/p4pgms/sr_test
\end{example}

In this example, there are seven processes running.  Five of the
processes are on symm, including the master.  Two of the processes on
symm are in the master's procgroup and two are running in a separate
procgroup as if they were on a separate machine.  Of course, the last
two are running on mmax.

Finally, suppose that you have a fiber-channel network that parallels your
Ethernet, connecting the same machines, and that connections fro running
TCP/IP over the fiber-channel network are obtained by connecting to
\code{sun1-fc}, \code{sun2-fc}, etc.  Then even if \code{sun1} is the local
machine that you are logged into, you will want your procgroup file to look
like:


\begin{example}
    sun1-fc    0
    sun2-fc    1  /home/user/p4pgms/sun/prog1
    sun3-fc    1  /home/user/p4pgms/sun/prog2
\end{example}

Some notes about the contents of the procgroup file should be made at
this point.  First, the value of \code{n} on the local line can be zero,
i.e. the master may have no local slaves.  Second, the local machine
may be treated as if it is a remote machine by merely entering it in
some line as a remote machine.  Third, a single machine may be treated
as multiple remote machines by having the same remote machine name
entered on multiple lines in the procgroup file.  Fourth, if a single
machine is listed multiple times, those processes specified on each
line form a single cluster (share memory).  Fifth, the cluster size
specified for a uniprocessor should be 1, because all slaves in a
cluster are assumed to run in parallel and to share memory.

We refer to the original (master) process as the ``big master''.  The
first process created in each cluster is the ``remote master'' or the
``cluster master'' for that cluster.  
All p4-managed processes (see the procedure \code{p4_create_procgroup}) 
have unique integer id's beginning with 0.
The processes within a cluster are numbered consecutively.



\node Developing a Simple p4 Program, Command-Line Arguments, Specifying Processes in the Procgroup File, Top
\section{Developing a Simple p4 Program}

The real fun associated with any computing environment arrives when you
actually type in a program and run it yourself.  We will assume that
you have successfully installed p4 on your own system and are ready to
write a small program, compile it, and run it.




\begin{menu}
* A Minimal Example::
* A Minimal Example in Fortran::
* A More Complicated Example::
\end{menu}

\node A Minimal Example, A Minimal Example in Fortran, Developing a Simple p4 Program, Developing a Simple p4 Program
\subsection{A Minimal Example}

We will start with a tiny program in which the worker processes do no work, and
then expand its capabilities.  Edit a file called \file{p4simple.c} and type:

\begin{example}

    #include "p4.h"

    main(argc,argv)
    int argc;
    char **argv;
    \{
        p4_initenv(&argc,argv);
        p4_create_procgroup();
        worker();
        p4_wait_for_end();
    \}

    worker()
    \{
        printf("Hello from %d\verb+\+n",p4_get_my_id());
    \}

\end{example}

This is one of the simplest p4 programs that you can write.  Let's examine it.
The \code{#include "p4.h"} statement must appear in all programs that use any
p4 features.  The procedure \code{p4_initenv} must be invoked before any other
p4 procedures, and \code{p4_wait_for_end} must be invoked after all p4
processing is completed.  The \code{p4_get_my_id} returns a unique integer id
for each process, beginning with 0.  The procedure \code{p4_create_procgroup}
is responsible for creating all processes other than 0.  It has no effect if
called by any other processes than process 0.  The way in which
\code{p4_create_procgroup} determines how many other processes there should
be, and where they should run, will be discussed shortly.

All processes that this program executes invoke the worker procedure,
including process 0.  Thus, in this program, the master process acts
just like all other processes once it gets the environment
established.

To understand how things get started, let's consider two separate
situations.  In the first situation, all processes are running on a
single machine.  Then, when process 0 starts, it executes the
\code{p4_create_procgroup} procedure to start all other slaves.  The other
slaves are started on the same machine by means of a UNIX \code{fork}.

In the second situation, there may be slaves running both on the same
machine as process 0, and slaves running on other machines as well.
In this situation, the first slave running on a remote machine will
need to execute the main procedure.  It will discover that it is not
process 0.  However, as part of initialization, process 0 will
direct it to fork any additional slaves required on the same machine.

In some ways, the above example can be used as a prototype for all p4 programs,
just by varying the content of the \code{worker} routine.

\node A Minimal Example in Fortran, A More Complicated Example, A Minimal Example, Developing a Simple p4 Program
\subsection{A Minimal Example in Fortran}

Here is a Fortrran version of the program we just discussed.
\begin{example}
      program p4simple
      include 'p4f.h'

      call p4init()
      call p4crpg()
      call fworker()
      call p4cleanup()
      stop
      end

      subroutine fworker()
      include 'p4f.h'
      integer*4 procid

      procid = p4myid()
      print *,'Hello from ',procid

      end
\end{example}



\node A More Complicated Example,  , A Minimal Example in Fortran, Developing a Simple p4 Program
\subsection{A More Complicated Example}

Now, let's make the worker process a little bit more interesting.  Let's
assume that we have \code{nprocs} slaves with ids 
0, 1, 2, ... \code{nprocs} -1.  And, we want to write a program in which
every process sends a single message to every other slave, and then
receives a message from every other slave.  We might alter the code for
the worker procedure to be the following:

\begin{example}
    worker()
    \{
        char *incoming, *msg = "hello";
        int myid, size, nprocs, from, i, type;

        myid = p4_get_my_id();
        nprocs = p4_num_total_ids();
        for (i=0; i < nprocs; i++)
        \{
            if (i != myid)
                p4_send(100, i, msg, strlen(msg)+1);
        \}
        for (i=0; i < nprocs - 1; i++)
        \{
            type = -1;
            from = -1;
            incoming = NULL;
            p4_recv(&type,&from,&incoming,&size);
            printf("%d received msg=:%s: from %d",myid,incoming,from);
            p4_msg_free(incoming);
        \}
    \}
\end{example}

This program demonstrates several features of p4's support for
message-passing.  Before we get into the specifics however, let's
examine the overall logic of the program.  Each process determines its
own id and the total number of processes executing in this run
(including process 0).  Then, in the first for-loop, each process sends
a single message to each of the other processes.  Finally, in the
second for-loop, each process receives a message from each of the other
processes.

The \code{p4_send} call requires 4 arguments:
\begin{itemize}
\item a message type (arbitrarily chosen to be 100 here)
\item the id of the process to receive the message
\item the message itself
\item the size of the message
\end{itemize}

The use of \code{p4_recv} is slightly more complicated.  First, we assign -1
to each of the parameters \code{type} and \code{from}.  This is done because
-1 represents a wildcard value indicating we are willing to receive a message
of any type from any process.  Here, we could have coded type to be 100, and
specified from equal to the value of \code{i} each time through the loop
(skipping our own id).  By setting \code{incoming} to NULL, we have also
indicated to \code{p4_recv} that we do not have a buffer in which to place the
received message, so \code{p4_recv} should obtain a buffer for us and place
the message in that buffer.  \code{p4_recv} treats these three parameters as
both input and output values.  Thus, it alters the value of each such that
\code{type} and \code{from} indicate the type of message received and the id
of the process that sent it.  The value of \code{incoming} is altered to point
to the buffer where the message was placed.  The \code{size} parameter is
strictly an output parameter and indicates the size of the received message.
It is possible for the user to provide his own buffer; this will be
demonstrated later.

\cindex{deallocating buffers}
Finally, note that \code{p4_msg_free} frees the message buffer obtained by
\code{p4_recv.} The procedure \code{p4_msg_free} should be called only after
the contents of the message are no longer needed.  \code{P4_msg_free} should
be used to free these buffers because, although a user only sees the data
portion of a message, p4 internally represents a message as a structured data
item.

To compile and link this program for execution, you need to create a
makefile.  We will assume that you have installed p4 in
\file{/usr/local/p4} and that you have typed the program above into a
file name \file{p4simple.c} in the directory
\file{/home/mylogin/p4pgms}.

To build your makefile, copy the file
\begin{example}
    /usr/local/p4/messages/makefile.proto
\end{example}
\noindent
into your working directory.  This is a prototype makefile that
contains machine-independent information, and which p4 can use to build a
machine-specific makefile for your program.  This prototype makefile contains
information about several sample programs that demonstrate
message-passing in p4.  If you edit this file, you will see information
for making a program named \code{sr_test}.  Do a global change of
\code{sr_test} to \code{p4simple}.  You should also change the value of
\code{P4_HOME_DIR}.  It should contain the full
pathname of the p4 system, e.g. \file{/usr/local/p4}.  Now change
directories to \file{/usr/local/p4} and type:

\begin{example}
make makefiles P4ARCH=<machine_type> DIRS=/home/mylogin/p4pgms
\end{example}
\noindent
where \code{<machine_type>} is the machine type that you specified when
you installed p4 on your machine.  Now, you should be able to change
back to your directory and see a file named \file{Makefile} there.  
You should then be able to type:

\begin{example}
    make p4simple
\end{example}

There is one last piece missing before you can execute your program.  Recall
that \code{p4_create_procgroup} needs to know how many processes to start and
where to start them; it reads a file (called a \dfn{procgroup file}) to gather
this information.  P4 always assumes that you have a master process, and that
you describe the slave processes (process groups) in the procgroup file.  You
can name a procgroup file any name you choose, but \code{<progname>.pg} is the
default name.  For example, in this case your procgroup file should be named
\file{p4simple.pg}.  The information contained in procgroup files can get
fairly involved, but if you have a computer that supports shared memory among
processes, then you can code a very simple example at first.

Let us suppose first that you want to run your program on a network of
workstations.  Then your procgroup should look something like:

\begin{example}
    local O
    some.network.machine 1 /home/me/p4progs/p4simple
\end{example}

This file indicates that you wish to run only the master on the local machine
(the one you are logged into when you execute the program) and one slave on
the machine \code{some.network.machine}.

Now, all you have to do to run your program is type:

\begin{example}
    p4simple
\end{example}

You should see a line printed each time a process receives a message
from another process (on some machines, there may be a restriction that
only one process can do I/O, however such restrictions are not
common).  Experiment by changing the number of slaves indicated in the
procgroup file.

You may notice that even a small p4 program becomes large when linked
with the p4 library.  You might consider using \code{strip} to reduce
the size or removing \code{-g} from the CFLAGS in the makefile.


\node Command-Line Arguments, The p4 Function Library, Developing a Simple p4 Program, Top
\section{Command-Line Arguments}
\cindex{command-line arguments}

The command-line arguments to a p4 program are all optional.
\begin{example}
  -p4help            get this information, then exit
  -p4pg      <file>  set procgroup file
  -p4dbg    <level>  set debug level
  -p4rdbg   <level>  set remote debug level
  -p4gm      <size>  set global memory size
  -p4dmn   <domain>  provide local domain name
  -p4out     <file>  set output file for master
  -p4rout    <file>  set output file prefix for remote masters
  -p4ssport <port#>  set private port number for secure server
  -p4norem           don't start remote processes
  -p4log             enable internal p4 logging by alog
  -p4version         print current p4 version number
\end{example}

In version 1.4, these flag names are valid without their \code{p4} prefix, for
backward compatibility.

\cindex{starting processes by hand}
If one specifies \code{-p4norem} on the command line, p4 will not actually
start the processes.  The master process prints a message suggesting how the
user can do it.  The point of this option is to enable the user to start the
remote processes under his favorite debugger, for instance.  The option only
makes sense when processes are being started remotely, such as on a
workstation network.


\node The p4 Function Library, p4 Functions for Managing Processes and Clusters, Command-Line Arguments, Top
\section{The p4 Function Library}




\begin{menu}
* Overview of the Library::
* Return Codes from p4 Functions::
\end{menu}

\node Overview of the Library, Return Codes from p4 Functions, The p4 Function Library, The p4 Function Library
\subsection{Overview of the Library}

In the following sections, we provide details for each p4 function in the
library.  The procedures are gathered into the following groups:

\begin{itemize}
\item Functions for managing processes and clusters
\item Functions for message passing
\item Functions for shared memory
\item Functions for timing p4 programs
\item Functions for debugging p4 programs
\item Miscellaneous functions
\item Fortran interface functions
\end{itemize}


\node Return Codes from p4 Functions,  , Overview of the Library, The p4 Function Library
\subsection{Return Codes from p4 Functions}
\cindex{return codes}

Most p4 functions return -1 if an error occurs.  Some, however, call the
function \code{p4_error} when severe errors occur.  This function prints a
message and then attempts to terminate all of the user's processes
\xref{Functions for Debugging p4 Programs}.


\node p4 Functions for Managing Processes and Clusters, Functions for Message Passing, The p4 Function Library, Top
\section{p4 Functions for Managing Processes and Clusters}

In some situations a p4 procedure will give an error message and then
exit.  This is typically done as a result of a failed system call and
handled by calling the p4 procedure named \code{p4_error} that examines the
return values from socket procedures, etc.  Most of the time however,
the procedures simply return a value.  Some of the procedures return no
value and thus are declared to return \code{VOID}.  Some of the
procedures return either a pointer to a character string or \code{NULL};
\code{NULL} indicates an error.  The remaining procedures return an
integer value; (-1) indicates an error.





\begin{menu}
* Functions for Process Management::
* Functions for Cluster Management::
\end{menu}

\node Functions for Process Management, Functions for Cluster Management, p4 Functions for Managing Processes and Clusters, p4 Functions for Managing Processes and Clusters
\subsection{Functions for Process Management}
\cindex{process management}

In this section we describe the p4 functions needed for basic creation and
termination of processes.

\findex{p4_initenv}
\begin{example}
int p4_initenv(argc,argv)
int *argc;
char **argv;
\end{example}
\noindent 
should be called by your program before an attempt is made to use
any p4 procedures or data areas.  We suggest making it the first executable
statement in your program.  \code{p4_initenv} parses the command line
arguments and extracts the ones intended for p4 ignoring all others (see the
discussion of command line arguments).  Note that you pass the address of
\code{argc} to \code{p4_initenv} so that it can actually remove its own
arguments before your program looks at them.

\findex{p4_create}
\begin{example}
int p4_create(fxn)
int (*fxn)();

\findex{p4_create_procgroup}
int p4_create_procgroup()
\end{example}
\noindent
There are two procedures that you can use to create processes in p4,
\code{p4_create_procgroup} and \code{p4_create}.  Processes created via
\code{p4_create} are said to be ``user-managed'' whereas those created
by \code{p4_create_procgroup} are ``p4-managed''.  The p4-managed
processes are automatically assigned unique id's (beginning with 0 for
the big master), they have message queues allocated for them so that
they can do message-passing, and they are able to run either on a
shared-memory multiprocessor with the creating process or they can run
on a separate machine.  Processes created via \code{p4_create} do not
have any of these advantages.  They must develop their own id's, they
cannot do message-passing, and they can only run on a shared-memory
multiprocessor with the creating process.  The only disadvantage of
\code{p4_create_procgroup} is that you must build a \file{procgroup}
file describing the set of required slave processes before the master
program begins execution.  This eliminates the possibility of
determining late in the execution exactly how many processes you want
to use to solve a problem.  Generally, this is not a problem,
especially since we can combine \code{p4_create_procgroup} and
\code{p4_create} in the following way: You can use
\code{p4_create_procgroup} to develop a network of processes that talk
to each other via messages.  Each of those processes can create further
processes to help it out as necessary.  The original set of processes
communicate with their local slaves through shared data areas and with
each other via message-passing.

\code{p4_create} receives one argument that is a pointer to a function.  It
creates a single new process that executes the indicated function.  The
new process may share data areas (in shared memory) with the parent
process.  However, the new process is not managed by the p4 system in
the sense that it is not assigned an id, it cannot pass messages, etc.
The only p4 procedure that deals with user-managed slaves is \code{p4_create}.
No other procedures are even aware of their existence.

\code{p4_create_procgroup} reads your procgroup file to determine the number
of slave processes to create and where they are to be placed.  It looks first
for the file specified on the command line following the \code{-p4pg} argument
if there is one.  If there is no such argument, it looks for a file with the
same name as the executable (master) file, with the \file{.pg} suffix.  If it
does not find one, it looks for a file named \file{procgroup}.  It builds a
procgroup table that describes all created processes and gives a copy of the
table to each process.  The processes then use the table to discover how to
communicate with each other (processes in a cluster can send messages directly
through shared memory or some other vendor-specific mechanism), others
communicate via sockets).  An alternative method is to build the table in
memory yourself and use \code{p4_startup}.

The effect of \code{p4_create_procgroup} can be obtained in another way if a
system would prefer to use its own way of specifying the locations of
processes.  A user may allocate the procgroup data structure and then fill it
in ``by hand'' rather than by reading a file in p4 procgroup format.  The
following procedures support this method of starting processes.

\findex{p4_alloc_procgroup}
\begin{example}
struct p4_procgroup *p4_alloc_procgroup()
\end{example}
\noindent
allocates a procgroup data structure of the form described in \code{p4.h}.
The formats of individual entries (\code{p4_procgroup_entry}) are given there
as well. 

\findex{p4_startup}
\begin{example}
int p4_startup(pg)
struct p4_procgroup *pg;
\end{example}
\noindent
starts processes as specified by an an already-created procgroup data
structure allocated by \code{p4_alloc_procgroup} and filled in by the user
using the structures \code{p4_procgroup_entry} and \code{p4_procgroup}.


\findex{p4_wait_for_end}
\begin{example}
VOID p4_wait_for_end()
\end{example}
\noindent
is the p4 termination/cleanup procedure that you should invoke at
the end of every execution of a program that uses p4.  For the master process,
it does some termination processing and then waits for slave processes to end.
It should be called by all processes.

\findex{p4_get_my_id}
\begin{example}
int p4_get_my_id()
\end{example}
\noindent
returns an integer value representing the id of the process assigned by
the p4 system.  If the process is not a p4-managed process, the value
(-1) is returned.

\findex{p4_num_total_ids}
\begin{example}
int p4_num_total_ids()
\end{example}
\noindent
returns an integer value indicating the total number of ids started
by p4 in all clusters, including the big master and all remote masters.

\findex{p4_num_total_slaves}
\begin{example}
int p4_num_total_slaves()
\end{example}
\noindent
returns an integer value indicating the total number of processes started
by p4 in all clusters, including all remote masters but not the big master.


\node Functions for Cluster Management,  , Functions for Process Management, p4 Functions for Managing Processes and Clusters
\subsection{Functions for Cluster Management}
\cindex{cluster management}

The p4 system supports the \dfn{cluster} model of parallel computation, in
which subsets of processes share memory with one another, with the clusters
communicating via messages.  A procgroup file for a program written for the
cluster model might look like this:

\begin{example}
    local                4
    alliant1.abc.edu     5 /home/me/myprog
    alliant2.abc.edu     5 /home/me/myprog
    encore.somewhere.edu 5 /usrs/me/myprog
\end{example}

This would specify a total of 20 processes, 5 (including the master) running
on the local machine (here assumed to be capable of supporting five processes
that share memory) together with 5 slaves each on three other shared-memory
machines.  One process out of each set of remote slaves will be the ``remote
master'' for that cluster..

\findex{p4_get_cluster_ids}
\begin{example}
VOID p4_get_cluster_ids(start,end)     
int *start;
int *end;
\end{example}
\noindent
receives pointers to two integers.  It places the p4-assigned id's of
the first and last id's within the current cluster into the two
arguments (including the remote master).

\findex{p4_get_my_cluster_id}
\begin{example}
int p4_get_my_cluster_id()
\end{example}
\noindent
returns a unique id (relative to 0) within a cluster of p4-managed
processes.  Thus, a cluster master will always have a cluster id of 0.
It is not clear that a separate cluster id is really useful, but the
functionality is provided just in case.

\findex{p4_am_i_cluster_master}
\begin{example}
BOOL p4_am_i_cluster_master()
\end{example}
\noindent
returns a BOOL value indicating whether the invoking process is the
``cluster master'' process within its cluster.

\findex{p4_num_cluster_ids}
\begin{example}
int p4_num_cluster_ids()
\end{example}
\noindent
returns an integer value indicating the number of ids in the current
cluster as started by \code{p4_create_procgroup}.  

\findex{p4_cluster_shmem_sync}
\begin{example}
VOID p4_cluster_shmem_sync(cluster_shmem)
VOID **cluster_shmem;
\end{example}
\noindent
This routine is used to synchronize the processes in a cluster before they
begin to use shared memory.

\findex{p4_get_cluster_masters}
\begin{example}
VOID p4_get_cluster_masters(numids, ids)
int *numids, ids[];
\end{example}
\noindent
This procedure fills in the values of \code{numids} and \code{ids}.
It obtains the p4-id's of all ``cluster masters'' for the program, placing
them in the \code{ids} array and placing the number of id's in \code{numids}.


\node Functions for Message Passing, Functions for Shared Memory, p4 Functions for Managing Processes and Clusters, Top
\section{Functions for Message Passing}
\cindex{message-passing functions}

P4 supports a set of send/receive procedures.  These procedures are
``generic'' in the sense that they do not know whether a message must
travel across a network or through shared memory, or via some other
mechanism.  They depend on a lower-level set of procedures that handle
local or network (remote) communications.  By default, the messages
are assumed to be typed.  If the user wishes to use untyped messages,
he can hide the typing by coding some very simple C macros that always
use a single message type.





\begin{menu}
* Explicit Sending and Receiving of Messages::
* Global Operations::
\end{menu}

\node Explicit Sending and Receiving of Messages, Global Operations, Functions for Message Passing, Functions for Message Passing
\subsection{Explicit Sending and Receiving of Messages}

\cindex{sending messages}
\findex{p4_send}
\findex{p4_sendr}
\findex{p4_sendx}
\findex{p4_sendrx}
\findex{p4_sendb}
\findex{p4_sendbr}
\findex{p4_sendbx}
\findex{p4_sendbrx}
\begin{example}
p4_send(type,to,msg,len)
p4_sendr(type,to,msg,len)
p4_sendx(type,to,msg,len,datatype)
p4_sendrx(type,to,msg,len,datatype)
p4_sendb(type,to,msg,len)
p4_sendbr(type,to,msg,len)
p4_sendbx(type,to,msg,len,datatype)
p4_sendbrx(type,to,msg,len,datatype)

int type, to, len, datatype;
char *msg;
\end{example}
\noindent

Each of these procedures sends a message.  The \code{type} argument is an
integer value chosen by the user to represent a message type.  The \code{to}
argument is an integer value that specifies the p4-id of the process that
should receive the message.  The \code{len} argument contains the length in
bytes of the message to be passed.  Note that some of the procedures have a
``b'' in their name, e.g.  \code{p4_sendb}.  These procedures assume that the
msg is in a buffer that the user obtained earlier via a \code{p4_msg_alloc};
otherwise, the buffer is assumed to be in the user's local space, and may
cause the message to be copied internally.  The procedures with an ``r'' in
the name do not return until an acknowledgement is received from the \code{to}
process (the ``r'' stands for rendezvous).  Those procedures with an ``x'' in
the name take an extra argument (datatype) that specifies the type of data in
the message; these procedures will use that information to call XDR for data
conversion if the message is being passed to a machine of a different
architecture, i.e. where the internal representation may be different.  The
valid values for the \code{datatype} parameter are \code{P4INT},
\code{P4DBL}, \code{P4FLT}, \code{P4LNG}, and \code{P4NOX}.  The last of
these means ``no translation''.


\findex{p4_messages_available}
\begin{example}
BOOL p4_messages_available(req_type,req_from)
int *req_type,*req_from;
\end{example}
\noindent
returns a BOOL value indicating whether the process has any messages available
or not.  The parameters \code{req_type} and \code{req_from} are both pointers
to integers; they are used as {\em both} input and output arguments.  On input,
\code{req_type} has a value that indicates the type of message that the user
wishes to check for availability (-1 indicates any type).  The variable
\code{req_from} is used similarly to indicate who a message is desired from.

\cindex{receiving messages} \findex{p4_recv}
\begin{example}
int p4_recv(req_type,req_from,msg,len_rcvd)
int *req_type,*req_from,*len_rcvd;
char **msg;
\end{example}
\noindent
takes four arguments.  The \code{msg} argument is a pointer to a
pointer to a \code{char}.  If this value is NULL, then p4 will allocate the
buffer for the message according to its length.  That is, one need not know
ahead of time the length of a message being received.  If this value is not
NULL, then it points to a p4 message buffer that the user has obtained via
\code{p4_msg_alloc}.  The \code{len_rcvd} argument is a pointer to an integer
that is assigned the length of the received message.  \code{Req_type} and
\code{req_from} are both pointers to integers; they are used as both input and
arguments.  On input, \code{req_type} has a value that indicates the type of
message that the user wishes to receive (-1 indicates any type).  It will
block until a message of that type is available.  \code{Req_from} is used
similarly to indicate who a message is desired from.  One important note about
this procedure is that it obtains the area in which to place a message, and
the user must explicitly free that area when finished with it (see
\code{p4_msg_free}).  There is an option available with \code{p4_recv} in
which the user can provide his own buffer rather than having p4 allocate it.
To do this, the user points \code{msg} to a buffer that he must obtain via a
call to \code{p4_msg_alloc} (see below).  No \code{p4_msg_free} should
be performed if the same buffer is going to be re-used multiple times.

\cindex{allocating buffers}
\findex{p4_msg_alloc}
\begin{example}
char *p4_msg_alloc(len)
int len;
\end{example}

\cindex{deallocating buffers}
\findex{p4_msg_free}
\begin{example}
VOID p4_msg_free(m)
char *m;
\end{example}
\noindent

obtain and free a buffer area that can be used to receive a 
message.  This procedure should be used for this task because a 
message has hidden information which the user is unaware of and 
therefore should not use \code{malloc} to obtain the area.



\node Global Operations,  , Explicit Sending and Receiving of Messages, Functions for Message Passing
\subsection{Global Operations}
\cindex{global operations}

P4 supports a number of operations for dealing with all processes at once.

\findex{p4_broadcast}
\begin{example}
p4_broadcast(type, data, data_len)
int type;
char *data;
int data_len;
\end{example}

\findex{p4_broadcastx}
\begin{example}
p4_broadcastx(type, data, data_len, data_type)
int type;
char *data;
int data_len, data_type;
\end{example}
\noindent
provide the ability to broadcast messages like \code{p4_send} and
\code{p4_sendx}.  These are semantically equivalent to a loop which uses
\code{p4_send} or \code{p4_sendx} to individually send a message to each other
process (the sender is not included.)  Messages sent by one of these
broadcasts are received by normal \code{p4_recv}'s.  The implementation of
\code{p4_broadcast} is more efficient than such a loop, since it uses a
``broadcast tree''.  One situation to look out for is a normal
\code{p4_broadcast} followed by a \code{p4_send}.  It is possible for the first
message to arrive at its destination {\em after\/} the second one.  The order
of messages in this situation can be enforced with the use of the \code{type}
argument. 

\findex{p4_global_op}
\begin{example}
p4_global_op(type,x,nelem,size,op,data_type) 
int type;
char *x;
int size, nelem;
int (*op)();
int data_type;
\end{example}
\noindent
where \code{op} is one of:
\begin{example}
p4_int_absmax_op()
p4_int_absmin_op()
p4_int_max_op()
p4_int_min_op()
p4_int_mult_op()
p4_int_sum_op()
p4_dbl_absmax_op()
p4_dbl_absmin_op()
p4_dbl_max_op()
p4_dbl_min_op()
p4_dbl_mult_op()
p4_dbl_sum_op()
p4_flt_absmax_op()
p4_flt_absmin_op()
p4_flt_max_op()
p4_flt_min_op()
p4_flt_mult_op()
p4_flt_sum_op()
\end{example}

\noindent
and \code{data_type} is one of \code{P4INT}, \code{P4LNG}, \code{P4FLT}, or
\code{P4DBL}.

This collection of routines provide the ability to do a variety of global
operations.  See the example program \file{p4/messages/systest.c}.  They apply
the commutative and associative operation \code{op} globally to \code{x} on an
element-by-element basis and broadcast the result to all nodes.  That is, each
process ends up with

\begin{example}
   for (i=0; i<n; i++)
         x[i] = x[node 0][i] op x[node 1][i] op x[node 2][i] op ...
\end{example}
\noindent
\code{op} should be of the form

\begin{example}
     VOID op(char *x, char *y, int nelem)
     \{
         data_type *a = (data_type *) x;
         data_type *b = (data_type *) y;

         while (nelem--)
             *a++ operation= *b++;
     \}
\end{example}
\noindent
where \code{data_type} and \code{operation} are chosen appropriately.

The order in which nodes apply the operation is undefined (hence \code{op}
must be commutative and associative). The communication may be internally
sub-blocked so the function \code{op} should not be hardwired to specific
vector lengths.

This is still a relatively primitive version, which gathers the necessary data
up a balanced binary tree and then uses \code{p4_broadcast} to send the
results back.  The \code{type} argument specifies the message type to be used
in the communication associated with this global operation.

Strictly speaking, the \code{size} parameter, which is size in bytes of one
element, is unnecessary.  It is retained for backward compatibility.

\cindex{barrier}
\findex{p4_global_barrier}
\begin{example}
VOID p4_global_barrier(type)
int type;
\end{example}
\noindent
This procedure takes one argument which is the message type to be 
used for internal message-passing.  It causes the invoking process to
hang until all processes specified in the procgroup file have invoked 
the procedure.



\node Functions for Shared Memory, Functions for Timing p4 Programs, Functions for Message Passing, Top
\section{Functions for Shared Memory}
\cindex{shared memory functions}
\cindex{shared memory example}


Here is a simple example of a shared-memory program using monitors.  In this
program, each process retrieves values from a shared loop index.  A
\dfn{monitor} is used to ensure that all values are retrieved exactly once.

\begin{example}
#include "p4.h"

struct globmem \{
    p4_getsub_monitor_t getsub;
\} *glob;

main(argc,argv)
int  argc;
char **argv;
\{
    p4_initenv(&argc,argv);

    glob = (struct globmem *) p4_shmalloc(sizeof(struct globmem));
    p4_getsub_init(&(glob->getsub));

    p4_create_procgroup();
    worker();
    p4_wait_for_end();
\}

worker()
\{
    int i, nprocs;

    nprocs = p4_num_total_ids();
    i = 0;
    while (i >= 0)
    \{
        p4_getsub(&(glob->getsub),&i,10,nprocs);
        p4_dprintf("I got %d\verb+\+n",i);
    \}
\}

\end{example}




\begin{menu}
* Managing Shared and Local Memory::
* Shared Memory Data Types::
* Monitor-Building Primitives::
* Some Useful Monitors::
\end{menu}

\node Managing Shared and Local Memory, Shared Memory Data Types, Functions for Shared Memory, Functions for Shared Memory
\subsection{Managing Shared and Local Memory}

The following functions are just basic memory management routines.

\findex{p4_malloc}
\begin{example}
char *p4_malloc(n)
int n;
\end{example}
\noindent
typically acts like the standard \code{malloc}, but may be rewritten for user 
systems that require different operation.

\findex{p4_free}
\begin{example}
VOID p4_free(p)
char *p;
\end{example}
\noindent
typically acts like the standard \code{free}, but may be rewritten for
user systems that require different operation.

\findex{p4_shmalloc}
\begin{example}
char *p4_shmalloc(n)
int n;
\end{example}
\noindent
acts like the standard \code{malloc} except will obtain shared memory on
machines that support sharing memory among processes.  Compare with
\code{p4_malloc}.

\findex{p4_shfree}
\begin{example}
VOID p4_shfree(p)
char *p;
\end{example}
\noindent
frees memory obtained with \code{p4_shmalloc}.  Compare with \code{p4_free}.



\node Shared Memory Data Types, Monitor-Building Primitives, Managing Shared and Local Memory, Functions for Shared Memory
\subsection{Shared Memory Data Types}
\cindex{shared memory data types}
\cindex{monitor data types}
\cindex{data types for monitors}

The abstraction provided by p4 for managing data in shared memory is
\dfn{monitors}.  Good places to learn about the monitor concept in general are
\cite{pbh:architecture} and \cite{hoare:monitors}.  The specific approach
taken by p4 is described in \cite{lusk-overbeek:p4-book}.  P4 provides several
useful monitors (\code{p4_barrier_t}, \code{p4_getsub_monitor_t},
\code{p4_askfor_monitor_t}) as well as a general monitor type to help the user
in constructing his own monitors (\code{p4_monitor_t}).


\node Monitor-Building Primitives, Some Useful Monitors, Shared Memory Data Types, Functions for Shared Memory
\subsection{Monitor-Building Primitives}
\cindex{monitor primitives}

The following functions can be used to construct monitors.  A monitor so
constructed has the type \code{p4_monitor_t}.

\findex{p4_moninit}
\begin{example}
int p4_moninit(m,i)
p4_monitor_t *m;
int i;
\end{example}
\noindent
initializes the monitor pointed to by \code{m} and gives it \code{i}
queues for processes to wait on while they are blocked (see \code{p4_mdelay}).
One queue is sufficient for most purposes.  The queues are numbered beginning
with 0.

\findex{p4_menter}
\begin{example}
VOID p4_menter(m)
p4_monitor_t *m;
\end{example}
\noindent
enter the monitor pointed to by \code{m}.  By the definition of a monitor,
access is restricted to a single process in the monitor at a time (if
everybody plays by the rules).

\findex{p4_mexit}
\begin{example}
VOID p4_mexit(m)
p4_monitor_t *m;
\end{example}
\noindent
exits the monitor pointed to by \code{m}.  You are of course assumed to have
previously entered that monitor.

\findex{p4_mcontinue}
\begin{example}
VOID p4_mcontinue(m,i)
p4_monitor_t *m;
int i;
\end{example}
\noindent
checks to see if there are any processes blocked on the \code{i}-th queue of
the monitor \code{m} and causes one of them to be released for entry to the
monitor if so.  If there are no such processes, the invoking process
simply exits.  Note that a process could have been blocked previously
by invoking the procedure \code{p4_mdelay}.  The queues are numbered 
beginning with 0.

\findex{p4_mdelay}
\begin{example}
VOID p4_mdelay(m,i)
p4_monitor_t *m;
int i;
\end{example}
\noindent
permits a process to delay itself on the \code{i}-th queue of monitor
\code{m} if the process wishes to release the monitor, but wants to be
waked up by another process later (via the procedure \code{p4_mcontinue}).
The queues are numbered beginning with 0.



\node Some Useful Monitors,  , Monitor-Building Primitives, Functions for Shared Memory
\subsection{Some Useful Monitors}
\cindex{monitors}

In this section we describe some of the specific monitors that are built into
the p4 library.  Each of them has its own pre-defined type, which can be
used to allocate storage for them, which should be in shared memory.
See the \file{p4/monitors} directory for examples.  A lock is itself a
monitor, with no extra delay queues.

\findex{p4_lock_init}
\begin{example}
VOID p4_lock_init(l)
p4_lock_t *l;
\end{example}
\noindent
initializes the lock \code{l}.  Must be used prior to any attempts to lock or
unlock \code{l}.

\cindex{lock}
\findex{p4_lock}
\begin{example}
VOID p4_lock(l)
p4_lock_t *l;
\end{example}
\noindent
blocks if the lock \code{l} is already locked, otherwise locks \code{l}
and proceeds.

\cindex{unlock}
\findex{p4_unlock}
\begin{example}
VOID p4_unlock(l)
p4_lock_t *l;
\end{example}
\noindent
unlocks the lock \code{l}.

\findex{p4_getsub}
\begin{example}
VOID p4_getsub(gs,s,max,nprocs)
p4_getsub_monitor_t *gs;
int *s,max,nprocs;
\end{example}
\noindent
is a procedure used to obtain the next value of a shared counter
(subscript).  It takes as its first argument, a pointer to a getsub
monitor that protects the shared counter.  It assigns the current value
of the counter to the integer that s points to, and then increments the
counter by 1.  \code{p4_getsub_init} initially sets the counter to 0.
When the counter passes the value \code{max}, all \code{nprocs}
processes are returned the value (-1) once, then the counter is reset to
0 for further use.

\findex{p4_getsubs}
\begin{example}
VOID p4_getsubs(gs,s,max,nprocs,stride)
p4_getsub_monitor_t *gs;
int *s,max,nprocs,stride;
\end{example}
\noindent
is like \code{p4_getsub} except that the counter is increased on each call by
\code{stride} instead of 1.


\findex{p4_getsub_init}
\begin{example}
int p4_getsub_init(gs)
p4_getsub_monitor_t *gs;
\end{example}
\noindent
initializes the getsub monitor pointed to by \code{gs}; this initialization
includes assigning a value of 0 to the counter that the monitor
protects.


The standard barrier synchronization pattern is expressed as a monitor.
There can be multiple barrier monitors, and one can wait for only some
of the processes at the barrier if this is desired.

\cindex{barrier}
\findex{p4_barrier}
\begin{example}
VOID p4_barrier(b,nprocs)
p4_barrier_monitor_t *b;
int nprocs;
\end{example}
\noindent
causes the executing process to hang until \code{nprocs} processes execute
a barrier instruction with a pointer to the same barrier monitor \code{b}
as an argument.

\findex{p4_barrier_init}
\begin{example}
int p4_barrier_init(b)
p4_barrier_monitor_t *b;
\end{example}
\noindent
initializes the barrier monitor \code{b}; this procedure should be invoked
before you attempt to use the monitor in any operations.

Finally, the \code{askfor} monitor functions like a general dispatcher of
work. 

\cindex{askfor monitor}
\findex{p4_askfor}
\begin{example}
int p4_askfor(af,nprocs,getprob_fxn,problem,reset_fxn)
p4_askfor_monitor_t *af;
int nprocs;
int (*getprob_fxn)();
VOID *problem;
int (*reset_fxn)();
\end{example}
\noindent
requests a new ``problem'' to work on from the problem pool.  The
arguments are (1) a pointer to the askfor monitor that protects the
problem pool, (2) the number of processes that call this procedure
(with \code{af}) looking for work, (3) a pointer to the user-written procedure
that obtains a problem from the pool, (4) a pointer that is filled in
with the address of a user-defined representation of a problem to be
solved, and (5) a pointer to a user-written procedure to reset when all
problems in the pool are solved, in case the same monitor is re-used
for another set of problems later.  \code{p4_askfor} returns an integer
indicating whether a problem was successfully obtained or not:

\begin{example}
  -1     : program is terminating (some process called p4_progend)
   0     : a problem was obtained and ``problem'' points to it
   1     : problem solved by exhaustion, i.e. no more problems to get
   n > 1 : a process found a solution and called p4_probend with code n
\end{example}
\noindent
For a detailed discussion of the ``askfor'' monitor, see
\cite{lusk-overbeek:p4-book}.

\findex{p4_update}
\begin{example}
int p4_update(af,putprob_fxn,problem)
p4_askfor_monitor_t *af;
int (*putprob_fxn)();
VOID *problem;
\end{example}
\noindent
updates the problem pool being managed by the askfor monitor.  The
arguments are (1) a pointer to the askfor monitor that protects the
problem pool, (2) a pointer to the user-written procedure that puts
problems into the pool, and (3) a pointer to a user-defined
representation of a problem to be put in the pool.  \code{Putprob_fxn}
should return 1 if it did indeed put a new problem into the pool, so
that any delayed processes should wake up and re-examine the pool (this
logic is handled by the \code{p4_askfor}) and 0 if upon entering the
monitor and examining its potential problem together with the data there
it decided not to add a new problem to the pool.  It can be assumed that
the ``putprob'' logic (defined by \code{putprob_fxn}) is executed inside
the monitor.

\findex{p4_askfor_init}
\begin{example}
int p4_askfor_init(af)
p4_askfor_monitor_t *af;
\end{example}
\noindent
initializes the askfor monitor \code{af}; this procedure should be invoked
before you attempt to use the monitor in any operations.

\findex{p4_probend}
\begin{example}
VOID p4_probend(af,code)
p4_askfor_monitor_t *af;
int code;
\end{example}
\noindent
allows the user process to mark a problem as solved early when
several processes are coordinating their activities via an askfor
monitor.  The code is an integer value that will be returned to all
processes when they ``askfor'' a new sub-problem to work on.

\findex{p4_progend}
\begin{example}
VOID p4_progend(af)
p4_askfor_monitor_t *af;
\end{example}
\noindent
allows a process to cause a return code of (-1) to be returned to all
processes using an askfor monitor.  This would typically be called by
a master process to indicate that no more problems are to be solved
and that all slave processes should terminate.



\node Functions for Timing p4 Programs, Functions for Debugging p4 Programs, Functions for Shared Memory, Top
\section{Functions for Timing p4 Programs}
\cindex{timing}
\cindex{clocks}
A small number of simple functions are available for accessing various
clocks and timers.  

\findex{p4_clock}
\begin{example}
int p4_clock()
\end{example}
\noindent
returns a value in milliseconds.  This is a wall-clock value, usually obtained
from the system via \code{gettimeofday}.  Also see \code{p4_ustimer} below.

\findex{p4_ustimer}
\begin{example}
p4_usc_time_t p4_ustimer()
\end{example}
\noindent
returns a wall-clock time value in microseconds.  The precision of this
number depends on the timer installed on the individual machine.  In
some cases the resolution may be no greater than that of \code{p4_clock()}.
For arithmetic and printing purposes, the type \code{p4_usc_time_t} is an
unsigned long integer.

\findex{p4_usrollover}
\begin{example}
p4_usc_time_t p4_usrollover()
\end{example}
\noindent
returns the timer value at which a microsecond timer ``rolls over''.
Since \code{p4_usc_time_t} is a long integer's worth of microseconds, it is
likely that the timer will roll over (become zero) during even
medium-length runs (about 72 minutes on most machines).



\node Functions for Debugging p4 Programs, Miscellaneous Functions, Functions for Timing p4 Programs, Top
\section{Functions for Debugging p4 Programs}
\cindex{debugging}

P4 has a set of routines to aid in producing a printed trace of events, both
user-defined and pre-defined in the p4 system.

\findex{p4_dprintf}
\begin{example}
VOID p4_dprintf(fmt, va_alist)
char *fmt;
va_dcl
\end{example}
\noindent
acts just like the standard \code{printf} except that the print line is
preceded by a value that identifies the process.  This value is
typically the string \code{pn_u} where \code{n} represents the
p4-assigned id and \code{u} represents the unix-id of the process on its
host.  However, there are other forms of this value.  For example, the
big master is represented as \code{bm_u}.  Also, if a process prints
before it has a p4-assigned id, then its value will be something like
\code{bm_slave_n_u} or \code{rm_slave_n_u}.  Typically, it is not
possible for a user program to print anything before being assigned an
id by p4, but the p4 system itself may use this procedure to print
messages from a particular process if it encounters problems getting the
process initialized.

\findex{p4_dprintfl}
\begin{example}
VOID p4_dprintfl(level, fmt, va_alist)
int level;
char *fmt;
va_dcl
\end{example}
\noindent
is like \code{p4_dprintf} except that the first argument is an integer
indicating the debugging level that must be in effect before this
message will print.  A level of 0 will cause the message to always print.
If you run a program with the debug level set to 5 (via command-line
arguments), then all \code{dprintfl}'s with level less than or equal to
that debug level will print. \xref{Command-Line Arguments} for how to
set the debug level at run time.

The debug level can be examined and changed by the user during execution:

\findex{p4_get_dbg_level}
\begin{example}
int p4_get_dbg_level()     
\end{example}
\noindent
returns the current debug level for this process and its cluster.

\findex{p4_set_dbg_level}
\begin{example}
VOID p4_set_dbg_level(level)     
int level;
\end{example}
\noindent
sets the current debug level for this process and its cluster.
P4 itself is liberally instrumented with \code{p4_dprintfl}'s of level
10 and above, leaving levels 0-9 for the user.  The greater the debug
level of the built-in messages, the greater understanding of p4 needed
by the user to make sense of them.  However, levels as high as 30 may
well be useful to the user trying to debug a p4 program.
Roughly speaking, the following debug levels produce messages about the
indicated events.

\begin{example}
level 10:  created process
           sent message
           received message

level 20:  creating process
           sending message
           receiving message
           process starting
           process exiting

level 30:  waiting for ack
           sending ack
           sent ack
           received ack
           queueing message for later receipt
           queued message for later receipt

level 40:  memory management
           buffer management

level 50:  reading procgroup
           other initialization message exchange

level 60:  send-receive details, especially machine-specific traces

level 70:  listener interactions:
            creating listener
            created listener
            messages from inside listener

level 80:  detailed data structures after initialization

level 90:  detailed tracing of flow thru procedures
\end{example}

For optimum performance, the test of the debug level required by these
messages can be removed at compile time by not commenting out the 
\code{#define P4_DPRINTFL} line in the \file{OPTIONS}
file (\xref{Introduction}).


The following function is provided to deal with abnormal termination.
It can be called by any process.

\findex{p4_error}
\begin{example}
VOID p4_error(string, value)
char *string;
int value;
\end{example}
\noindent
prints \code{string} as an error message and then forcefully terminates
all co-operating processes and cleans up all shared resources.

\findex{p4_soft_errors}
\begin{example}
VOID p4_soft_errors(onoff)     
int onoff;
\end{example}
\noindent
enables/disables soft errors, returning the previous setting.  The default
is ``disabled'', which means that certain p4 functions will call
\code{p4_error} instead of returning -1.

\cindex{interrupts}
\code{p4_error} gets control on certain kinds of interrupts.  It is
automatically called for \code{SIGSEGV}, \code{SIGBUS}, and \code{SIGFPE}
interrupts, to catch user programming errors and clean up, after which it
returns interrupt handling to default mode and returns, so that the user
may obtain a dump.  It also handles \code{SIGINT} interrupts, in which case
it cleans up and exits.  Finally, it may be called directly by the user, in
which case it cleans up (other p4 processes and IPC's) and exits.

\cindex{runaway processes}
Although \code{p4_error} is supposed to get rid of all running p4
processes, it can happen that an error is bad enough that p4 processes
are left running.  A primitive aid in finding and killing these
processes is the shell script \code{kj}, which takes a string as an
argument and then kills processes containing that string as part of
their program names.  Currently it only kills processes on the machine
where it is run, but it can be run via \code{rsh} on remote machines.
There are other useful scripts (e.g. \code{killipc} and \code{killp4})
in the \file{p4/bin} directory to do such things as clean up SYSV IPC 
items that may be left when a program abnormally terminates.  P4 will 
generally cleanup these items if the abnormal termination is a type that 
p4 traps, otherwise the user must do the cleanup.  This is an unfortunate
side-effect of the way that SYSV handles things, it really should be
the OS's function to take care of this.

On many machines it is possible to attach a debugger like \code{dbx} to a
running process.  This is one way to find out where a hanging process is
stuck. 


\node Miscellaneous Functions, Fortran Interface, Functions for Debugging p4 Programs, Top
\section{Miscellaneous Functions}

In this section are found functions that do seem to fit neatly into any of the
other sections.

\findex{p4_version}
\begin{example}
char *p4_version()
\end{example}
\noindent
returns a string containing the version number of p4 being run.

\findex{p4_print_avail_buffs}
\begin{example}
VOID p4_print_avail_buffs()
\end{example}
P4 maintains an array of buffer lists of various sizes, so that it can very
rapidly allocate and deallocate buffers.  You can see the contents of the
buffer pools at any time by calling this procedure.

\cindex{buffer pool management}
\findex{p4_set_avail_buff}
\begin{example}
VOID p4_set_avail_buff(bufidx,size)
int bufidx;
int size;
\end{example}
\noindent
This procedure is used to set the size of buffers in p4's buffer pools.  The
parameter \code{bufidx} specifies a particular buffer list, and should be a
number from 0 to 7.  The \code{size} parameter specifies that buffers up to
that size will be managed by p4 in a particular list.  It is important to
maintain the buffer sizes in increasing order.  The default list of buffer
sizes is {64, 256, 1024, 4096, 16384, 65536, 262144, 1048576}.  This causes
wasted space if you send only one large message, causing the allocation of a
large buffer which is not reused.  Savings in space can be achieved by
adjusting these numbers to correspond with the message sizes of your
application.  If no large messages are sent at all, however, no space is
wasted since the large buffers will never be allocated.  If you send a message
larger that the largest size in this array, p4 will allocate the buffer, and
then free it back to the system as soon as it can.



\node Fortran Interface, Faster Startup with the Secure Server, Miscellaneous Functions, Top
\section{Fortran Interface}
\cindex{Fortran interface}


In this section we describe the p4 Fortran library.  All Fortran programs must
include the file \file{p4f.h} from the directory \file{lib_f}.  The Fortran
calls to p4 procedures are analogous to their C counterparts, but have
Fortran-like names.  You might find the documentation for the corresponding C
routine, in one of the sections above, helpful.

\findex{p4init}
\begin{example}
p4init()
\end{example}
\noindent
should be called by your program before an attempt is made to use
any p4 procedures or data areas.  We suggest making it the first executable
statement in your program.

\findex{p4crpg}
\begin{example}
p4crpg()
\end{example}
\noindent
This routine should be called by the master process (the one started directly
by you) to read the procgroup file and start the processes specified there.
It can be called by other process, but has no effect in that case.

\findex{p4myid}
\begin{example}
integer p4myid()
\end{example}
\noindent
returns an integer value representing the id of the process assigned by
the p4 system.

\findex{p4cleanup}
\begin{example}
p4cleanup()
\end{example}
\noindent
should be called by the master process to wait for the termination of the
processes created by \code{p4crpg}.

\findex{p4send}
\begin{example}
p4send(type,dest,msg,len,rc)
integer type, dest, len, rc
real msg
\end{example}
\noindent

\findex{p4sendx}
\begin{example}
p4sendx(type,dest,msg,len,data_type,rc)
integer type, dest, len, data_type, rc
real msg
\end{example}
\noindent

\findex{p4sendr}
\begin{example}
p4sendr(type,dest,msg,len,rc)
integer type, dest, len, rc
real msg
\end{example}
\noindent

\findex{p4sendrx}
\begin{example}
p4sendrx(type,dest,msg,len,data_type,rc)
integer type, dest, len, data_type, rc
real msg
\end{example}
\noindent
Each of these procedures sends a message.  The \code{type} argument
is an integer value chosen by the user to represent a message type.  The
\code{dest} argument is an integer value that specifies the p4-id of the
process that should receive the message.  The \code{len} argument contains the
length in bytes of the message to be sent.  The procedures with an ``r'' in
the name do not return until an acknowledgement is received from the \code{to}
process (the ``r'' stands for rendezvous).  Those procedures with an ``x'' in
the name take an extra argument (datatype) that specifies the type of data in
the message; these procedures will use that information to call XDR for data
conversion if the message is being passed to a machine of a different
architecture, i.e. where the internal representation may be different.  p4
maintains an internal table of which pairs of machine types require
conversion, so it only does the conversion when it is necessary.  The valid
values for the \code{data_type} parameter are \code{P4INT}, \code{P4DBL},
\code{P4FLT}, \code{P4LNG}, and \code{P4NOX}.  The last of these means ``no
translation''.

\findex{p4recv}
\begin{example}
p4recv(type,from,buf,buflen,msglen,rc)
integer type, from, buflen, msglen, rc
real buf
\end{example}
\noindent
The \code{buf} parameter is the buffer into which the message is to
be received.  It can be of any Fortran type.  The \code{buflen} parameter
specifies its length, so that p4 can check for overruns.  The number of bytes
actually received is given by \code{msglen}.  The \code{type} and \code{from}
parameters specify the message type and the source of the message.  If either
of these is set to -1, then screening is not applied, and the parameter is set
to indicate the type and/or source of the message actually received.
\code{rc} is the return code from the call.

\findex{p4probe}
\begin{example}
p4probe(type,from,rc)
\end{example}
\noindent
sets \code{rc} to 1 or 0 depending on whether the process has any
messages available or not.  The parameters \code{type} and \code{from} are
used as {\em both} input and arguments.  On input, \code{type} has a value
that indicates the type of message that the user wishes to check for
availability (-1 indicates any type).  The variable \code{from} is used
similarly to indicate who a message is desired from.

\findex{p4brdcst}
\begin{example}
p4brdcst(type,data,len,rc)
integer type, len, rc
real data
\end{example}

\findex{p4brdcstx}
\begin{example}
p4brdcstx(type,data,len,data_type,rc)
integer type, len, data_type, rc
real data
\end{example}
\noindent
provide the ability to broadcast messages like \code{p4send} and
\code{p4sendx}.  These are semantically equivalent to a loop which uses
\code{p4send} or \code{p4sendx} to individually send a message to each
other process (the sender is not included.)  Messages sent by one of these
broadcasts are received by normal \code{p4recv}'s.  The implementation of 
\code{p4brdcst} is more efficient than such a loop, since it uses a
``broadcast tree''.

\findex{p4ntotids}
\begin{example}
integer p4ntotids()
\end{example}
\noindent
returns an integer value indicating the total number of processes started
by the p4 master process and all remote processes.  It includes the master
process itself.

\findex{p4nslaves}
\begin{example}
integer p4nslaves()
\end{example}
\noindent
returns an integer value indicating the total number of processes started
by p4, not including the original master process.

\findex{p4nclids}
\begin{example}
integer p4nclids()
\end{example}
\noindent
returns an integer value indicating the number of ids in the current
cluster as started by \code{p4crpg}.  

\findex{p4myclid}
\begin{example}
integer p4myclid()
\end{example}
\noindent
returns a unique id (relative to 0) within a cluster of p4-managed
processes.  Thus, a cluster master will always have a cluster id of 0.

\findex{p4globarr}
\begin{example}
p4globarr(type)
integer type
\end{example}
\noindent
takes one argument which is the message type to be used for internal
message-passing.  It causes the invoking process to wait until all processes
specified in the procgroup file have invoked the procedure.

\findex{p4getclmasts}
\begin{example}
p4getclmasts(numids,ids)
integer numids, ids(*)
\end{example}
\noindent
This procedure fills in the values of numids and ids.  It obtains the
p4-ids of all ``cluster masters'' for the program, placing them in the
ids array and placing the number of ids in numids.

\findex{p4getclids}
\begin{example}
p4getclids(start,end)
integer start, end
\end{example}
\noindent
receives two integers.  It places the p4-assigned id's of
the first and last ids within the current cluster into the two
arguments (including the remote master).

\findex{p4clock}
\begin{example}
integer p4clock()
\end{example}
\noindent
returns a value in milliseconds.  This is a wall-clock value, usually obtained
from the system via \code{gettimeofday}.  Also see \code{p4ustimer} below.

\findex{p4ustimer}
\begin{example}
integer p4ustimer()
\end{example}
\noindent
returns a wall-clock time value in microseconds.  The precision of this
number depends on the timer installed on the individual machine.  In
some cases the resolution may be no greater than that of \code{p4clock()}.

\findex{p4flush}
\begin{example}
p4flush()
\end{example}
\noindent
flushes standard out.  On some systems this needs to be done explicitly for
prompts.  This is just a convenience routine that has nothing to do with p4.

\findex{p4error}
\begin{example}
p4error(str,val)
character*n str
integer val
\end{example}
\noindent
prints \code{string} as an error message and then forcefully terminates
all p4 processes.

\findex{p4softerrs}
\begin{example}
p4softerrs(new,old)
integer new, old
\end{example}
\noindent
enables/disables soft errors, returning the previous setting in
\code{old}.  The default is ``disabled'', which means that certain p4
functions will call \code{p4_error} instead of returning -1.

\findex{p4version}
\begin{example}
integer p4version()
\end{example}
\noindent
returns a string containing the version number of p4 being run.

\findex{p4avlbufs}
\begin{example}
p4avlbufs()
\end{example}
\noindent
P4 maintains an array of buffer lists of various sizes, so that it can very
rapidly allocate and deallocate buffers.  You can see the contents of the
buffer pools at any time by calling this procedure.

\findex{p4setavlbuf}
\begin{example}
p4setavlbuf(idx,size)
integer idx, size
\end{example}
\noindent
This procedure is used to set the size of buffers in p4's buffer pools.  The
parameter \code{bufidx} specifies a particular buffer list, and should be a
number from 0 to 7.  The \code{size} parameter specifies that buffers up to
that size will be managed by p4 in a particular list.  It is important to
maintain the buffer sizes in increasing order.  The default list of buffer
sizes is {64, 256, 1024, 4096, 16384, 65536, 262144, 1048576}.  This causes
wasted space if you send only one large message, causing the allocation of a
large buffer which is not reused.  Savings in space can be achieved by
adjusting these numbers to correspond with the message sizes of your
application.  If no large messages are sent at all, however, no space is
wasted since the large buffers will never be allocated.  If you send a message
larger that the largest size in this array, p4 will allocate the buffer, and
then free it back to the system as soon as it can.

\findex{p4globop}
\begin{example}
p4globop(type,x,nelem,size,op,data_type,rc)
\end{example}
\noindent
where \code{op} is one of:
\begin{example}
   p4intsumop
   p4intabsmaxop
   p4intabsminop
   p4intmaxop
   p4intminop
   p4intmultop
   p4dblsumop
   p4dblabsmaxop
   p4dblabsminop
   p4dblmaxop
   p4dblminop
   p4dblmultop
   p4fltsumop
   p4fltabsmaxop
   p4fltabsminop
   p4fltmaxop
   p4fltminop
   p4fltmultop
\end{example}

The \code{data_type} parameter in the above operations should be one of
\begin{example}
  P4INT
  P4LNG
  P4FLT
  P4DBL  
\end{example}
\noindent
These symbolic constants are defined in the include file \file{p4f.h}.  The
\code{size} argument is the size in bytes of one element, and the \code{type}
argument is the message type used in the global operation.

There are also Fortran routines for creating logfiles
\xref{Creating Log Files in Fortran}.


\node Faster Startup with the Secure Server, Utilities for Managing a p4 Session, Fortran Interface, Top
\section{Faster Startup with the Secure Server}
\cindex{faster startup}
\cindex{servers}
\cindex{permissions}
\cindex{rhosts}

P4 processes on remote machines are ordinarily created by \code{rsh}.
For this to work, the user must have permission to create processes on
that machine.  This permission is normally granted either globally by
the system administrator, or locally by the use of \file{.rhosts} files.
(See the normal unix man pages under \code{rhosts}).

Since \code{rsh} is relatively slow, p4 provides a way to get things
started faster.  This is accomplished by running the program
\code{serv_p4} in the background on the remote machine.  When p4 is
creating processes, it will automatically check for the existence of
this server and use it if it is running.  Remote processes typically
start much faster when the server is running. 
When p4 uses \code{rsh}, the remote process's \code{stdout} is sent
back to the \code{stdout} of the parent (the p4 master process).
We have not yet tested this server on all of the machines that we support.
Thus far, we have tested it somewhat on the SYMMETRY, SUN, DEC5000, and
SGI.  We believe that it will work on many other machines, but have not
yet verified it on all machines.

An invocation of a set of servers is (currently) associated with a specific
port number.  This way multiple users can each be running multiple server
networks without mutual interference, provided each network of servers is
started with a different port number. 

To start the secure server on a machine one can do

\begin{example}
serv_p4 -d -p <num>
\end{example}

\noindent
where \code{<num>} is a port number to be associated with a network of
servers.  If the \code{-p} option is omitted, the server will pick an unused
port number and report

\begin{example}
Listening on <num>.
\end{example}

\noindent
Then p4 programs to use this network should be started with 

\begin{example}
-p4ssport <num>
\end{example}

The p4 application must also be listed in the user's \file{.p4apps} file in
his home directory.  This file should be readable only by the user, and should
contain the full path names of programs that the user wishes to be startable
by the p4 server.

When a p4 master process tries to start a slave process on a remote machine,
it will first attempt to do it via the server.  If it cannot do so for any
reason (no server running, port number mismatch, or program not found in
\file{.p4apps} file), then it tries to do so with the remote shell command.

Note that the server is used only to start processes; it plays no role in a p4
computation once the slave processes have been initiated.  Rather, a temporary
process, called the {\em listener}, is spawned to manage connection requests
that occur during the execution of a p4 program.  Neither the server nor the
listener consumes any significant amount of CPU time.

There is further discussion of installation options for the servers in
the \file{README} file in the \file{p4/servers} subdirectory.


\node Utilities for Managing a p4 Session, Creating Logfiles for Upshot, Faster Startup with the Secure Server, Top
\section{Utilities for Managing a p4 Session}
\cindex{utilities}
\cindex{servers}

A number of useful utilities can be found in the \file{bin} subdirectory.
These can be used to start and stop server processes based on the contents of
a file of machines one regularly uses, to kill runaway p4 processes in the
unlikely case that they cannot or do not terminate automatically when one
processes ends abnormally or is interrupted from the keyboard, and to merge
logfiles created for the use of \code{upshot} (\xref{Creating Logfiles for
Upshot}).  Some of these scripts may have to be edited to reflect the
installation directory of p4.

\begin{description}
\item[start_servers] Use a port number from the command line and afile of
  machine--program pairs to start a set of secure servers.
\item[kill_servers]  Use the same file to kill a set of secure servers.
\item[killp4] Kills p4 processes, given a procgroup file and a program name on
  the local machine. 
\item[mergelogs] A C program to merge logfiles.  Its source code is in the
  \code{alog} directory, but the makefile deposits the executable here.
\item[listener_p4]  The code for the standalone listener.
\item[adjlogs] A C program to line up the timestamps when logs are taken from
  different machines on a network.  The source is in the \code{alog}
  directory, but the executable goes here.  It cannot be made on all machines,
  because it uses an extended-precision math library.  It works on Suns.
\end{description}



\node Creating Logfiles for Upshot, Running p4 on Specific Machines, Utilities for Managing a p4 Session, Top
\section{Creating Logfiles for Upshot}
\cindex{tracefiles}
\cindex{upshot}
\cindex{logging}
\cindex{timestamps}

P4 is distributed with a set of routines for creating logfiles (see
\file{README} in the \file{p4/alog} directory.  The resulting logfiles
can be examined by \code{upshot}, distributed separately.  For details
about \code{upshot}, see \cite{herrarte-lusk:upshot}.  

The \file{p4/alog} directory contains a package (ALOG) for creating logs of
time-stamped events, that is of general utility, outside of p4.  The
timestamps are obtained from various microsecond-level resolution timers on
various machines.  The portable microsecond timing package is contained in the
\file{usc} subdirectory.  It is used by the ALOG package as well as by the
\code{p4_ustimer} function in p4.  Similarly, the ALOG package can be used
independently of p4 and \code{upshot}. Its logfiles were designed to be read
and displayed by upshot, but other display packages can be used as well.




\begin{menu}
* User-Specified Events::
* Creating Log Files in Fortran::
* Examining Log Files with Upshot::
* Automatic Logging of p4 Events::
\end{menu}

\node User-Specified Events, Creating Log Files in Fortran, Creating Logfiles for Upshot, Creating Logfiles for Upshot
\subsection{User-Specified Events}
\cindex{user events}

The ALOG package consists of a set of macros that can be used to instrument a
C program and a set of functions that can be used to instrument a Fortran
program.  We will focus here primarily on the use of the C interface, which
contains more functionality.

The macros that can be used to instrument a program are as follows (from the 
file \file{README_ALOG} in the \file{alog} directory):

\findex{ALOG_SETUP}
\begin{example}
ALOG_SETUP(pid,flag):	
  pid  -  (integer) process id of callee
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE  
\end{example}
\noindent
This macro initializes the tracing area for a slave process and must be called
once before any event is logged.  If the value of \code{flag} is set to
\code{ALOG_WRAP}, then in the event of no more space for logging events the
system will only report the latest n events.  If \code{flag} is set to
\code{ALOG_TRUNCATE} the system will stop logging events as soon as there is
no more memory for the events to be logged.

\findex{ALOG_MASTER}
\begin{example}
ALOG_MASTER(pid,flag):
  pid  -  (integer) process id of the callee
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE  
\end{example}
\noindent
This macro has the same effect over its parameters as
\code{ALOG_SETUP} with the difference that this macro should be referenced by
the master process only.

\findex{ALOG_DEFINE}
\begin{example}
ALOG_DEFINE(event,strdef,format):
  event  - (integer) id of event being defined
  strdef - (string) description of 'event'
  format - (string) control string in "printf" format 
\end{example}
\noindent
This macro puts an event definition code into the logfile.

\findex{ALOG_LOG}
\begin{example}
ALOG_LOG(pid,event,intdata,strdata):
  pid     - (integer) process id of callee
  event   - (integer) event id to be logged
  intdata - (integer) any integer data for this event
  strdata - (string) any string data (can be the null string)
\end{example}
\noindent
This macro provides the event logging service.

\findex{ALOG_OUTPUT}
\begin{example}
ALOG_OUTPUT
  no parameters  
\end{example}
\noindent
This macro dumps the events logged into a log file with the name
\file{alogfile.pxx} where \code{xx} is the logical PID of the callee process.
The log file is created in the current directory unless specified otherwise
through the macro ALOG_SETDIR.  All processes should execute this.

\findex{ALOG_SETDIR}
\begin{example}
ALOG_SETDIR(dir)
  dir - (string) directory where log file is created
\end{example}
\noindent
This macro sets the output directory for the log file.  The default directory
for the creation of the log file is the current directory of the process.  If
used, then this macro MUST be invoked before \code{ALOG_MASTER/ALOG_SETUP}.

\findex{ALOG_STATUS}
\begin{example}
ALOG_STATUS(status):
  status - (integer) either ALOG_ON or ALOG_OFF
\end{example}
\noindent

This macro controls the logging status of \code{ALOG} as follows.  Setting
\code{status} to \code{ALOG_ON} enables logging until it is turned off.
Setting \code{status} to \code{ALOG_OFF} disables logging until it is turned
on again.  Logging is enabled at the outset by default.


\findex{ALOG_ENABLE}
\begin{example}
ALOG_ENABLE
  no parameters
\end{example}
\noindent

This macro enables event logging; same as calling \code{ALOG_STATUS(ALOG_ON)}.

\findex{ALOG_DISABLE}
\begin{example}
ALOG_DISABLE
  no parameters
\end{example}
\noindent
This macro disables event logging; same as calling
\code{ALOG_STATUS(ALOG_OFF)}.

The sample program \file{gridlog.shmem.c} in the \file{monitors} subdirectory
contains an example of a program instrumented with ALOG statements.  The macro
definitions for ALOG are included when you include \code{#include "p4.h"} in
your program.  If the line \code{#define ALOG_TRACE} is not included before
the \code{#include "p4.h"}, these macros will generate no code.  Thus it is
easy to effectively de-instrument the code by recompiling, and there is no
need to protect each ALOG statement with an \code{#ifdef}.
 
\findex{mergelogs}
\cindex{merging log files}
When an ALOG-instrumented program is run, it will produce one logfile for each
process.  The files will be named \file{alogfile.p0}, \file{alogfile.p1},
\ldots.  These files need to be merged into a single file with the events
sored by timestamp.  This is accomplished with the program \file{mergelogs},
found in the \file{bin} subdirectory.  To merge the logfiles, do 

\begin{example}
mergelogs alogfile.p* > myprog.log
rm alogfile.p*
\end{example}

The resulting logfile can be examined by upshot or some other logfile
examination facility.  See \cite{herrarte-lusk:upshot} for details of the
logfile format.

\findex{adjlogs}
\cindex{adjusting timestamps in log files}
On networks of workstations and some distributed memory machisnes, the
microsecond timers on the various processors are synchronized.  To produce a
usable merged logfile, the \file{adjlogs} program, also found in the
\file{bin} directory, can be used to adjust the timestamps for offset and
drift before they are merged.  For this to work, synchronization events must
be placed in the logfiles by an \code{ALOG_LOG} statement.  The event type
is then passed to \code{adjlogs}, which aligns the timestamps, based on the
timestamps of the synchonization events.  The call to \code{adjlogs} looks
like this, where \code{<n>} is the type of the synchronization event.  This
program makes us of high-precision numeric libraries, and has been tested only
on Sun's.

\begin{example}
adjlogs -e <n>
\end{example}

Both \code{mergelogs} and \code{adjlogs} are less portable than the other p4
code;  you might want to run them on a workstation such as a Sun.



\node Creating Log Files in Fortran, Examining Log Files with Upshot, User-Specified Events, Creating Logfiles for Upshot
\subsection{Creating Log Files in Fortran}
\cindex{logfiles in Fortran}
\cindex{upshot}

Log files can also be created by Fortran programs.  The routines to do so are:


\findex{alogfsetup}
\begin{example}
alogfsetup(pid,flag):	
  pid  -  (integer) process id of callee
  flag -  (integer) either ALOG_WRAP or ALOG_TRUNCATE  
\end{example}
\noindent
This function initializes the tracing area for a slave process and must be called
once before any event is logged.  If the value of \code{flag} is set to
\code{ALOG_WRAP}, then in the event of no more space for logging events the
system will only report the latest n events.  If \code{flag} is set to
\code{ALOG_TRUNCATE} the system will stop logging events as soon as there is
no more memory for the events to be logged.

\findex{alogfmaster}
\begin{example}
alogfmaster(pid,flag):
  pid  -  (integer) process id of the callee
  flag -  (integer) either 0 or 1  (see above)
\end{example}
\noindent
This function has the same effect over its parameters as
\code{alogfsetup} with the difference that this function should be referenced by
the master process only.

\findex{alogfdefine}
\begin{example}
alogfdefine(event,strdef,format):
  event  - (integer) id of event being defined
  strdef - (string) description of 'event'
  format - (string) control string in "printf" format 
\end{example}
\noindent
This function puts an event definition code into the logfile.

\findex{alogflog}
\begin{example}
alogflog(pid,event,intdata,strdata):
  pid     - (integer) process id of callee
  event   - (integer) event id to be logged
  intdata - (integer) any integer data for this event
  strdata - (string) any string data (can be the null string)
\end{example}
\noindent
This function provides the event logging service.

\findex{alogfoutput}
\begin{example}
alogfoutput()
\end{example}
\noindent
This function dumps the events logged into a log file with the name
\file{alogfile.pxx} where \code{xx} is the logical PID of the callee process.
The log file is created in the current directory unless specified otherwise
through the function \code{alogfsetdir}.

\findex{alogfsetdir}
\begin{example}
alogfsetdir(dir)
  dir - (string) directory where log file is created
\end{example}
\noindent
This function sets the output directory for the log file.  The default directory
for the creation of the log file is the current directory of the process.  If
used, then this function MUST be invoked before \code{alogfmaster/alogfsetup}.

\findex{alogfstatus}
\begin{example}
alogfstatus(status):
  status - (integer) either ALOG_ON or ALOG_OFF
\end{example}
\noindent

This function controls the logging status of \code{ALOG} as follows.  Setting
\code{status} to \code{ALOG_ON} enables logging until it is turned off.
Setting \code{status} to \code{ALOG_OFF} disables logging until it is turned
on again.  Logging is enabled at the outset by default.


\findex{alogfenable}
\begin{example}
alogfenable()
\end{example}
\noindent

This function enables event logging; same as calling
\code{alogfstatus(ALOG_ON)}.  It must be called first, even before
\code{alogfmaster} or \code{alogfsetup}.

\findex{alogfdisable}
\begin{example}
alogfdisable()
\end{example}
\noindent
This function disables event logging; same as calling
\code{alogfstatus(ALOG_OFF)}.

The sample program \file{sr_log.f} in the \file{messages_f} subdirectory
contains an example of a Fortran program instrumented with logging statements.

\node Examining Log Files with Upshot, Automatic Logging of p4 Events, Creating Log Files in Fortran, Creating Logfiles for Upshot
\subsection{Examining Log Files with Upshot}
\cindex{upshot}
\cindex{statefile}

\code{Upshot} is not part of the p4 distribution, but can be obtained from the
same anonymous \code{ftp} location as p4.  Take the file \file{upshot.tar.Z}
from the directory \file{pub/p4} on \code{info.mcs.anl.gov}.  The distribution
contains all necessary documentation on how to install and run \code{upshot}.
It is an X-window program that runs on most workstations.  There is no need
for a parallel macchine to be involved, once the log files have been obtained.

\code{Upshot} produces the most interesting displays when certain events
(not necessarily all) are defined to be the entry and exit events for certain
{\it states} and then colors are associated with the states.  This association
is reflected in a {\it statefile} with a format like the following:

\begin{example}
1 1 2 red   asking
2 3 4 blue  working
3 5 6 green updating
\end{example}

This statefile describes three states.  State 1 is defined to be between
events 1 and 2.  \code{Upshot} will color it red and label it ``asking''.


\node Automatic Logging of p4 Events,  , Examining Log Files with Upshot, Creating Logfiles for Upshot
\subsection{Automatic Logging of p4 Events}
\cindex{automatic logging}

We have found that the most useful events to log and study are those
identified by the user and specified in his program.  That way he can control
the number of events to be logged and the grain size of the states that are
represented.  

In some cases, however, one wants to study the details of the internal
operation of a p4 application, or get some idea of the behavior on one's
program without going to the trouble of instrumenting it himself.  To this
end, p4 itself is instrumented with ALOG statements, although by default they
are inactive.  To get automatic logging of p4 events (including sending and
receiving of each message) one needs first to link to a version of the p4
library that has been compiled with the line \code{#define ALOG_TRACE}
uncommented out in the \file{OPTIONS} file, and secondly, to run with
\code{-p4log} on the command line.

Some important things to know about using the internal logging features of p4
are:

\begin{enumerate}
\item By default, logging is turned off at compile time in the OPTIONS file.
\item If you link to a version of p4 that was compiled with logging turned
  on in the OPTIONS file, then if you either use the -p4log option or do
  ALOG_ENABLE in the program, you will get p4 internal log stuff.  Of
  course, if you use ALOG_ENABLE and do some of your own logging, then it
  will be mixed up with p4's.  The assumption is that you would probably
  only link to a version of p4 that had internal logging turned on if you
  wanted to debug p4 internals.
\item If you link to a version of p4 that was compiled with logging turned off
  in the OPTIONS file, then using the -p4log option will have no effect; also,
  using ALOG_ENABLE will not cause p4 internals to log anything.  BUT, you can
  do a "#define ALOG_TRACE" at the top of your program and do ALOG_ENABLE,
  ALOG_LOGs, etc. and all of your own stuff will be logged.  NOTE that you must
  do the #define above your #include "p4.h" because p4.h includes the alog.h
  header file for you.
\item It is suggested that at least in the case of internal logging, processes
  should be created using \code{p4_create_procgroup} rather than
  \code{p4_create}.
\end{enumerate}


\node Running p4 on Specific Machines, Some Common Problems and their Solutions, Creating Logfiles for Upshot, Top
\section{Running p4 on Specific Machines}


\begin{menu}
* Invoking a p4 Program::
* Machine-Specific Notes::
\end{menu}

\node Invoking a p4 Program, Machine-Specific Notes, Running p4 on Specific Machines, Running p4 on Specific Machines
\subsection{Invoking a p4 Program}

\begin{description}
\item[Workstation Networks] On networks of uniprocessors consisting of Suns,
  HP machines, RS/6000's, CRAY's, SGI's, etc., just set up the appropriate
  procgroup file and execute the master process.  Execution of the
  \code{p4_create_procgroup} will start up the other processes, either via
  remote shell or the server.
\item[Shared-memory multiprocessors]  On machines such as the Sequent
  Symmetry, Encore, KSR, IBM 3090, or Alliant, just execute the master program.
\item[BBN Butterfly] On the Butterfly TC-2000, one should invoke a program
  with the ``cluster'' command:  \code{cluster 10 systest -pg myprocgroup},
  where \file{myprocgroup} describes 9 slave processes, or else the main
  program will \code{p4_create} 9 processes.
\item[IPSC860] See the script \file{runipsc} in the \file{messages} directory. 
\item[DELTA] See the script \file{rundelta} in the \file{messages} directory. 
\item[Paragon] To run on the Paragon at Caltech, execute the program with
  command-line arguments as follows:
  \begin{example}
    <progname>  -pn .compute -sz <nprocs>
  \end{example}
where {\tt nprocs} is the total number of processes.  On some Paragons,
 one must first create a partition with
  the \code{mkpart} command (\code{mkpart -sz <size> <partname>}),
  specifying the size and name of the partition.  At some installations, these
  partitions are specicified ahead of time.  (The \code{lspart} command says
  which partitions currently exist, and the \code{rmpart} command is used to
  remove a user-allocated partition.  Once you have a partition, start your
  program with:
\begin{example}
  myprog -pn <partition name>  
\end{example}
  The procgroup file should contain one line:
\begin{example}
  <machinename> <nprocs-1> <pathname>    
\end{example}
\item[CM-5] You are logged in to a particular front-end, which determines how
  many nodes you have available.  Just run the program.  The procgroup file
  should specify (as \code{local}) some number of slaves less than the number
  of nodes available.  Also include the program pathname on the \code{local}
  line in the procgroup file.  You don't have to use all the nodes.
\item[nCube] Say \code{xnc -dN progname} where \code{N} is the {\em
  dimension\/} of the subcube to be allocated (i.e., the number of nodes
  allocated will be 2 to the power N).  The procgroup file should look like
  the one for the CM-5.  Try \code{nman} to access the man pages.
\item[SP-1] The IBM SP-1 has several modes.  To run (at least on the Argonne
  system) with the Socket interface to the Ethernet, use \code{spnode}s in
  the procgroup file, including a
\begin{example}
  spnode1 0 <file>
\end{example}
  for the master.  To use the socket interface to the switch on the SP-1, use
  \code{swnode}s for the nodes, including \code{swnode1} for the master.
\item[SP1_EUI] To use the IBM EUI interface to the switch
  (\code{P4ARCH=SP1_EUI}), log into a node where EUI is running and do:
\begin{example}
  setenv MP_PROCS N  (where N is the number of processes you want)

     myprog
\end{example}
   or
\begin{example}
  myprog -procs N
\end{example}
  The procgroup file  should look like 
\begin{example}
  local 15 <progname>
\end{example}
to run with 16 processes (15 slaves).  The program name in the procgroup file
should be the full path name of the executable file.  Such a program may be
be interactive, but there currently are problems flushing lines to the
terminal that do not end in a newline character (typically, interactive
prompts). 
\item[SP1_EUIH] To use the experimental high-speed interface, log into a node
  where EUIH is running and do:
\begin{example}

  /usr/lpp/euih/eui/cotb0 -b <progname> <numprocs> <user args>

\end{example}

The procgroup file should look like 
\begin{example}
  local 15 <progname>
\end{example}
to run with 16 processes (15 slaves).  The program name in the procgroup file
should be the full path name of the executable file.  Such a program should
not be interactive.
\item[MEIKO_CS1] Find an appropriately sized partition using
\begin{example}
  rinfo -a
\end{example}
and then start the job with
\begin{example}
  prun -n <nprocs> -lsv [-p <partition name>] <progname>
\end{example}
The \code{-lsv} option causes stdout to be routed to files.
\end{description}


\node Machine-Specific Notes,  , Invoking a p4 Program, Running p4 on Specific Machines
\subsection{Machine-Specific Notes}

\begin{example}
SUN
    (1)  P4 can be installed on this machine with or without SYSV IPC.

SUN_SOLARIS
    (1)  P4 is made with shared memory by default, and instead of SysV shared
         memory, uses the more efficient mmap.

HP
    (1)  P4 can be installed on this machine with or without SYSV IPC.
    (2)  Fortran not tested (not avail on our test machine).

DEC5000
    (1)  P4 can be installed on this machine with or without SYSV IPC.

ALPHA
    (1)  P4 can be installed on this machine with or without SYSV IPC.

RS6000
    (1)  P4 can be installed on this machine with or without SYSV IPC.
    (2)  It is important to use the option -lbsd on the link step to
         get sockets to support the NONBLOCKING option.

IBM3090
    (1)  P4 can be installed on this machine with or without SYSV IPC.
    (2)  Fortran not supported due to absence of iargc/getarg.
    (3)  There are multiply defined macros in include/rpc/rpc.h.  IBM
         is fixing this in a later OS release.  Meanwhile make your own
         copy and the fix the problem yourself.
    
TITAN
    (1)  P4 can be installed on this machine with or without SYSV IPC.
    (2)  Fortran not supported due to problems with getting args.

SGI
    (1)  P4 can be installed on this machine with or without SYSV IPC.

NEXT
    (1)  Fortran not supported due to absence of iargc/getarg.

FX2800/FX2800_SWITCH
    (1)  Alliant's switch code not yet ensuring messages 
         remain ordered.  p4 currently discovers the switch port for
         the machine it is running on by invoking the internal
         procedure getswport.  This procedure must be customized to
         the installation.  Alliant's switch is currently unsupported.
      
FX8
    (1)  You might need to add MFLAGS = -i to the Makefile

KSR
    (1)  The latest version of the OS produces a link-time error for
         Fortran programs.
    (2)  Use of sockets fails because of a bug in socketpair.

IPSC860
    (1)  the script ``runcube'' (in the messages directory) may 
         be useful
	 
DELTA
    (1)  the script ``rundelta'' (in the messages directory) may 
         be useful

BALANCE
    (1)  Fortran not supported.

SYMMETRY/SYMMETRY_PTX
    (1)  -Z compiler option may be changed to control the
            shmalloc/malloc split.  This is often needed when
            creating logfiles on a symmetry.
    (2)  shared memory message passing not supported in Fortran

TC_2000/TC_2000_TCMP
    (1)  TCMP port not yet complete.
    (2)  For shared-memory execution, one must use \code{cluster ...} to
         obtain a private cluster for execution
NCUBE
    (1)  Messages are limited to 32K in length.

CM5 
    (1)  Logfiles are not supported.

SP1
    (1)  Using ``spnoden'' for node names causes p4 to use the TCP
         interface to the Ethernet.
    (2)  Using ``swnoden'' for node names causes p4 to use the TCP 
         interface to the switch.  In this case, replace the line
         ``local 0'' with ``swnode1 0'' in the procgroup file.
    (3)  It is important to use the option -lbsd on the link step to
         get sockets to support the NONBLOCKING option when using the 
         TCP interface to either the switch or the Ethernet.
    (4)  EUIH programs may not be able to read from the keyboard.
\end{example}


\node Some Common Problems and their Solutions, Concept Index, Running p4 on Specific Machines, Top
\section{Some Common Problems and their Solutions}
\cindex{problems}
\cindex{permission denied}

Our attempt with this manual has been to prevent you from having difficulties.
Experience shows that certain common problems recur, however.  In this
section we hope to address some of these problems.

\begin{description}
\item[``Permission Denied.''] p4 slave processes are started by forks (for
  slaves in the same shared-memory cluster), by the server, or by the remote
  shell command.  If the server is running on the target machine then that
  must be configured to allow remote processes to be started.  To test whether
  this is your problem, try
\begin{example}
    rsh target.machine date
\end{example}
  If you still get the ``Permission denied.'' message, then the problem has
  nothing to do with p4.  See \code{hosts.equiv} or \code{.rhosts} in the
  system man pages.
\item[``More processes than message queues'']  Under the default configuration
  of p4, uniprocessors, such as most workstations, cannot have multiple
  processes sharing memory.  Thus your procgroup file for a workstation network
  should always look like:
\begin{example}
    local 0
    machine1 1 pathname
    machine2 1 pathname
    machine3 1 pathname
       .
       .
\end{example}
  The ``local'' means ``only the master on the startup machine; no local
  slaves sharing memory''.

\cindex{IPC}
  It is possible, at some cost in message-passing efficiency, to have a
  cluster of processes sharing memory on a workstation, but in this case p4
  must have been installed with the \code{SYSV_IPC} option set in the
  \file{OPTIONS} file.  The cost is that a process waiting for a message must
  spin between checking for a message arriving on a socket and a message
  arriving through shared memory. 

\item[``cannot find procgroup file''] On the SP-1, Fortran EUIH programs that
  have been linked with the \code{-e main} option cannot find their
  command-line arguments, which are needed whether the procgroup file is named
  implicitly or explicitly.  The solution is to remove \code{-e main} from the
  link line in the makefile.

\item[``gethostbyname failed 100 times''] Check for an invalid machine name
  in the procgroup file.  If all machine names being used are correct,
  \code{p4dmn} command-line option might be helpful.  For example, if you are
  running the master program on a machine named ``donner'', then it will
  broadcast that name to other processes, but they may only be able to look
  ``donner'' up in a file that refers to it as ``donner.mcs.anl.gov'', so
  the \code{-p4dmn} option is used to supply the ``mcs.anl.gov'' part.
  
\item[``pgm\_path\_name: Command not found'']  P4 tried to start the program
  with the given name on a remote machine and the program did not exist.
  Verify the full path name of the program.
\item[program hangs]  You may have failed to initialize the \code{type} and
  \code{from} fields before a \code{p4_recv}.  You might have used
  \code{p4_sendr} between two processes at the same time, which will deadlock
  if you think about it, or even if you don't.  Use \code{p4_send} instead.
\item[program hangs or has bad data in received message]  You might have
  failed to set the pointer to the incoming buffer to NULL, or to have
  specifically allocated a buffer with \code{p4_msg_alloc}, before a
  \code{p4_recv}.
\item[program fails to terminate] Some Sequents and Suns have been found to be
  running an old version of \code{rsh}, which leaves \code{rsh} processes
  around, causing the master process not to terminate.  Be sure that you have
  applied patch  100468-03 to your \code{rsh}, which should make it 7374 bytes
  long. 
\item[program ignores command-line arguments]  You might have passed
  \code{argc} instead of \code{&argc} to \code{p4_initenv}.
\item[program runs out of memory]  You may need to call \code{p4_msg_free}
  after each \code{p4_recv}, or reuse buffers by pre-allocating them.


\end{description}

\twocolumn

\node Concept Index, Function Index, Some Common Problems and their Solutions, Top
\section{Concept Index}
\printindex{cp}



\node Function Index,  , Concept Index, Top
\section{Function Index}

\printindex{fn}

\onecolumn

\begin{tex}
\addcontentsline{toc}{section}{References}
\bibliography{p4}
\end{tex}

This copy was produced on \today.

\end{document}

